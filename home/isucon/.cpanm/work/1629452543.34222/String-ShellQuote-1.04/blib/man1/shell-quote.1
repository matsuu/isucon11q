.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "SHELL-QUOTE 1"
.TH SHELL-QUOTE 1 "2010-06-11" "perl v5.34.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
shell\-quote \- quote arguments for safe use, unmodified in a shell command
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\fBshell-quote\fR [\fIswitch\fR]... \fIarg\fR...
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBshell-quote\fR lets you pass arbitrary strings through the shell so that
they won't be changed by the shell.  This lets you process commands or
files with embedded white space or shell globbing characters safely.
Here are a few examples.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.IP "\fBssh preserving args\fR" 4
.IX Item "ssh preserving args"
When running a remote command with ssh, ssh doesn't preserve the separate
arguments it receives.  It just joins them with spaces and passes them to
\&\f(CW\*(C`$SHELL \-c\*(C'\fR.  This doesn't work as intended:
.Sp
.Vb 1
\&    ssh host touch \*(Aqhi there\*(Aq           # fails
.Ve
.Sp
It creates 2 files, \fIhi\fR and \fIthere\fR.  Instead, do this:
.Sp
.Vb 2
\&    cmd=\`shell\-quote touch \*(Aqhi there\*(Aq\`
\&    ssh host "$cmd"
.Ve
.Sp
This gives you just 1 file, \fIhi there\fR.
.IP "\fBprocess find output\fR" 4
.IX Item "process find output"
It's not ordinarily possible to process an arbitrary list of files
output by \fBfind\fR with a shell script.  Anything you put in \f(CW$IFS\fR to
split up the output could legitimately be in a file's name.  Here's how
you can do it using \fBshell-quote\fR:
.Sp
.Vb 1
\&    eval set \-\- \`find \-type f \-print0 | xargs \-0 shell\-quote \-\-\`
.Ve
.IP "\fBdebug shell scripts\fR" 4
.IX Item "debug shell scripts"
\&\fBshell-quote\fR is better than \fBecho\fR for debugging shell scripts.
.Sp
.Vb 3
\&    debug() {
\&        [ \-z "$debug" ] || shell\-quote "debug:" "$@"
\&    }
.Ve
.Sp
With \fBecho\fR you can't tell the difference between \f(CW\*(C`debug \*(Aqfoo bar\*(Aq\*(C'\fR
and \f(CW\*(C`debug foo bar\*(C'\fR, but with \fBshell-quote\fR you can.
.IP "\fBsave a command for later\fR" 4
.IX Item "save a command for later"
\&\fBshell-quote\fR can be used to build up a shell command to run later.
Say you want the user to be able to give you switches for a command
you're going to run.  If you don't want the switches to be re-evaluated
by the shell (which is usually a good idea, else there are things the
user can't pass through), you can do something like this:
.Sp
.Vb 10
\&    user_switches=
\&    while [ $# != 0 ]
\&    do
\&        case x$1 in
\&            x\-\-pass\-through)
\&                [ $# \-gt 1 ] || die "need an argument for $1"
\&                user_switches="$user_switches "\`shell\-quote \-\- "$2"\`
\&                shift;;
\&            # process other switches
\&        esac
\&        shift
\&    done
\&    # later
\&    eval "shell\-quote some\-command $user_switches my args"
.Ve
.SH "OPTIONS"
.IX Header "OPTIONS"
.IP "\fB\-\-debug\fR" 4
.IX Item "--debug"
Turn debugging on.
.IP "\fB\-\-help\fR" 4
.IX Item "--help"
Show the usage message and die.
.IP "\fB\-\-version\fR" 4
.IX Item "--version"
Show the version number and exit.
.SH "AVAILABILITY"
.IX Header "AVAILABILITY"
The code is licensed under the \s-1GNU GPL.\s0  Check
http://www.argon.org/~roderick/ or \s-1CPAN\s0 for updated versions.
.SH "AUTHOR"
.IX Header "AUTHOR"
Roderick Schertler <roderick@argon.org>
