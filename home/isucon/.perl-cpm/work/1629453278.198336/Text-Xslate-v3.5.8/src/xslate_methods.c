/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.43 from the
 * contents of xslate_methods.xs. Do not edit this file, edit xslate_methods.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "src/xslate_methods.xs"
#include "xs_version.h"
#include "xslate.h"

#define TXBM_DECL(name) void name \
    (pTHX_ tx_state_t* const st PERL_UNUSED_DECL, SV* const retval, SV* const method PERL_UNUSED_DECL, SV** MARK)

/* tx_bm _ TYPE _ MONIKER */
#define TXBM_NAME(t, n) CAT2( CAT2(tx_bm, _), CAT2(t, CAT2(_, n)))
#define TXBM(t, moniker) static TXBM_DECL( TXBM_NAME(t, moniker))

#define TXBM_SETUP(t, name, nargs_min, nargs_max) \
    { STRINGIFY(t) "::" STRINGIFY(name), TXBM_NAME(t, name), nargs_min, nargs_max }

typedef struct {
    const char* const name;

    TXBM_DECL( (*body) );

    U8 nargs_min;
    U8 nargs_max;
} tx_builtin_method_t;

#define MY_CXT_KEY "Text::Xslate::Methods::_guts" XS_VERSION
typedef struct {
    tx_state_t* cmparg_st;
    SV*         cmparg_proc;

    HV* pair_stash;
} my_cxt_t;
START_MY_CXT;

static SV*
tx_make_pair(pTHX_ HV* const stash, SV* const key, SV* const val) {
    AV* av;
    SV* pair[2];
    pair[0] = key;
    pair[1] = val;

    av = av_make(2, pair);
    return sv_bless( sv_2mortal( newRV_noinc((SV*)av) ), stash );
}

static I32
tx_pair_cmp(pTHX_ SV* const a, SV* const b) {
    assert(SvROK(a));
    assert(SvTYPE(SvRV(a)) == SVt_PVAV);
    assert(SvROK(b));
    assert(SvTYPE(SvRV(b)) == SVt_PVAV);

    return sv_cmp(
        *av_fetch((AV*)SvRV(a), 0, TRUE),
        *av_fetch((AV*)SvRV(b), 0, TRUE)
    );
}

static SV*
tx_keys(pTHX_ SV* const hvref) {
    HV* const hv    = (HV*)SvRV(hvref);
    AV* const av    = newAV();
    SV* const avref = sv_2mortal(newRV_noinc((SV*)av));
    HE* he;
    I32 i;

    assert(SvROK(hvref));
    assert(SvTYPE(hv) == SVt_PVHV);

    if(HvKEYS(hv) > 0) {
        av_extend(av, HvKEYS(hv) - 1);
    }

    hv_iterinit(hv);
    i = 0;
    while((he = hv_iternext(hv))) {
        SV* const key = hv_iterkeysv(he);
        (void)av_store(av, i++, key);
        SvREFCNT_inc_simple_void_NN(key);
    }
    sortsv(AvARRAY(av), i, Perl_sv_cmp);
    return avref;
}

/* NIL */

/* SCALAR */

/* ARRAY */
TXBM(array, first) {
    SV **svp = av_fetch((AV*)SvRV(*MARK), 0, FALSE);
    sv_setsv(retval, svp ? *svp : &PL_sv_undef);
}

TXBM(array, last) {
    AV* const av = (AV*)SvRV(*MARK);
    SV **svp = av_fetch(av, av_len(av), FALSE);
    sv_setsv(retval, svp ? *svp : &PL_sv_undef);
}

TXBM(array, size) {
    sv_setiv(retval, av_len((AV*)SvRV(*MARK)) + 1);
}

TXBM(array, join) {
    dSP;
    dORIGMARK;
    AV* const av     = (AV*)SvRV(*MARK);
    I32 const len    = av_len(av) + 1;
    I32 i;

    EXTEND(SP, len);
    MARK = ORIGMARK;
    for(i = 0; i < len; i++) {
        SV** const svp = av_fetch(av, i, FALSE);
        PUSHs(svp ? *svp : &PL_sv_undef);
    }
    /* don't do PUTBACK */

    MARK++;
    sv_setpvs(retval, "");
    do_join(retval, *MARK, MARK, SP);
}

TXBM(array, reverse) {
    AV* const av        = (AV*)SvRV(*MARK);
    I32 const len       = av_len(av) + 1;
    AV* const result    = newAV();
    SV* const resultref = sv_2mortal(newRV_noinc((SV*)result));
    I32 i;

    av_fill(result, len - 1);
    for(i = 0; i < len; i++) {
        SV** const svp = av_fetch(av, i, FALSE);
        (void)av_store(result, -(i+1), newSVsv(svp ? *svp : &PL_sv_undef));
    }

    sv_setsv(retval, resultref);
}

static I32
tx_sv_cmp(pTHX_ SV* const x, SV* const y) {
    dMY_CXT;
    dSP;
    tx_state_t* const st = MY_CXT.cmparg_st;
    SV* const proc       = MY_CXT.cmparg_proc;
    SV* result;

    assert(st);
    assert(proc);

    PUSHMARK(SP);
    /* no need to extend SP because of the args of the method (sort) is >= 2 */
    PUSHs(x);
    PUSHs(y);
    PUTBACK;
    result = tx_unmark_raw(aTHX_ tx_proccall(aTHX_ st, proc, "sort callback"));
    return SvIV(result);
}

static SVCOMPARE_t
tx_prepare_compare_func(pTHX_ tx_state_t* const st, I32 const items, SV** const MARK) {
    assert(items == 0 || items == 1);
    if(items == 0) {
        return Perl_sv_cmp;
    }
    else {
        dMY_CXT;
        SAVEVPTR(MY_CXT.cmparg_st);
        SAVESPTR(MY_CXT.cmparg_proc);

        MY_CXT.cmparg_st   = st;
        MY_CXT.cmparg_proc = *(MARK + 1);
        return tx_sv_cmp;
    }
}

TXBM(array, sort) {
    dSP;
    I32 const items     = SP - MARK;
    AV* const av        = (AV*)SvRV(*MARK);
    I32 const len       = av_len(av) + 1;
    AV* const result    = newAV();
    SV* const resultref = newRV_noinc((SV*)result);
    SVCOMPARE_t cmpfunc;
    I32 i;

    ENTER;
    SAVETMPS;
    sv_2mortal(resultref);

    cmpfunc = tx_prepare_compare_func(aTHX_ st, items, MARK);

    av_extend(result, len - 1);
    for(i = 0; i < len; i++) {
        SV** const svp = av_fetch(av, i, FALSE);
        (void)av_store(result, i, newSVsv(svp ? *svp : &PL_sv_undef));
    }
    sortsv(AvARRAY(result), len, cmpfunc);

    sv_setsv(retval, resultref);

    FREETMPS;
    LEAVE;
}

TXBM(array, map) {
    AV* const av        = (AV*)SvRV(*MARK);
    SV* const proc      = *(++MARK);
    I32 const len       = av_len(av) + 1;
    AV* const result    = newAV();
    SV* const resultref = newRV_noinc((SV*)result);
    I32 i;

    ENTER;
    SAVETMPS;
    sv_2mortal(resultref);
    av_extend(result, len - 1);
    for(i = 0; i < len; i++) {
        dSP;
        SV** const svp = av_fetch(av, i, FALSE);
        SV* sv;

        PUSHMARK(SP);
        /* no need to extend SP because of the args of the method is > 0 */
        PUSHs(svp ? *svp : &PL_sv_undef);
        PUTBACK;
        sv = tx_proccall(aTHX_ st, proc, "map callback");
        (void)av_store(result, i, newSVsv(sv));
    }
    /* setting retval must be here because retval is actually st->targ */
    sv_setsv(retval, resultref);
    FREETMPS;
    LEAVE;
}

TXBM(array, reduce) {
    AV* const av        = (AV*)SvRV(*MARK);
    SV* const proc      = *(++MARK);
    I32 const len       = av_len(av) + 1;
    SV** svp;
    SV* a;
    I32 i;

    if(len < 2) {
        svp = av_fetch(av, 0, FALSE);
        sv_setsv(retval, svp ? *svp : NULL);
        return;
    }

    ENTER;
    SAVETMPS;
    svp = av_fetch(av, 0, FALSE);
    a = svp ? *svp : &PL_sv_undef;

    for(i = 1; i < len; i++) {
        dSP;
        SV* b;
        svp = av_fetch(av, i, FALSE);
        b   = svp ? *svp : &PL_sv_undef;

        PUSHMARK(SP);
        PUSHs(a);
        PUSHs(b);
        PUTBACK;
        a = tx_proccall(aTHX_ st, proc, "reduce callback");
    }
    /* setting retval must be here because retval is actually st->targ */
    sv_setsv(retval, a);
    FREETMPS;
    LEAVE;
}

TXBM(array, merge) {
    AV* const av        = (AV*)SvRV(*MARK);
    SV* const value     = *(++MARK);
    I32 const len       = av_len(av) + 1;
    AV* const result    = newAV();
    SV* const resultref = newRV_noinc((SV*)result);
    AV* m = NULL;
    I32 mlen;
    I32 i;

    ENTER;
    SAVETMPS;
    sv_2mortal(resultref);

    if(tx_sv_is_array_ref(aTHX_ value)) {
        m    = (AV*)SvRV(value);
        mlen = av_len(m) + 1;
    }
    else {
        mlen = 1;
    }
    av_extend(result, len + mlen - 1);

    /* copy */
    for(i = 0; i < len; i++) {
        SV** const svp = av_fetch(av, i, FALSE);
        SV* const sv   = svp ? *svp : &PL_sv_undef;
        (void)av_store(result, i, newSVsv(sv));
    }
    /* merge */
    if(m) {
        for(i = 0; i < mlen; i++) {
            SV** const svp = av_fetch(m, i, FALSE);
            SV* const sv   = svp ? *svp : &PL_sv_undef;
            av_push(result, newSVsv(sv));
        }
    }
    else {
        av_push(result, newSVsv(value));
    }

    /* setting retval must be here because retval is actually st->targ */
    sv_setsv(retval, resultref);
    FREETMPS;
    LEAVE;
}

/* HASH */

TXBM(hash, size) {
    HV* const hv = (HV*)SvRV(*MARK);
    IV i = 0;
    hv_iterinit(hv);
    while(hv_iternext(hv)) {
        i++;
    }
    sv_setiv(retval, i);
}

TXBM(hash, keys) {
    sv_setsv(retval, tx_keys(aTHX_ *MARK));
}

TXBM(hash, values) {
    SV* const avref = tx_keys(aTHX_ *MARK);
    HV* const hv    = (HV*)SvRV(*MARK);
    AV* const av    = (AV*)SvRV(avref);
    I32 const len   = AvFILLp(av) + 1;
    I32 i;

    /* replace keys with values */
    /* map { $hv->{$_} } @{$keys} */
    for(i = 0; i < len; i++) {
        SV* const key = AvARRAY(av)[i];
        HE* const he  = hv_fetch_ent(hv, key, TRUE, 0U);
        SV* const val = hv_iterval(hv, he);
        SvREFCNT_dec(key);
        AvARRAY(av)[i] = newSVsv(val);
    }

    sv_setsv(retval, avref);
}

TXBM(hash, kv) {
    dMY_CXT;
    SV* const hvref = *MARK;
    HV* const hv    = (HV*)SvRV(hvref);
    AV* const av    = newAV();
    SV* const avref = newRV_noinc((SV*)av);
    HE* he;
    I32 i;

    ENTER;
    SAVETMPS;
    sv_2mortal(avref);

    if(HvKEYS(hv) > 0) {
        av_extend(av, HvKEYS(hv) - 1);
    }

    hv_iterinit(hv);
    i = 0;
    while((he = hv_iternext(hv))) {
        SV* const pair = tx_make_pair(aTHX_ MY_CXT.pair_stash,
            hv_iterkeysv(he),
            hv_iterval(hv, he));

        (void)av_store(av, i++, pair);
        SvREFCNT_inc_simple_void_NN(pair);
    }
    sortsv(AvARRAY(av), i, tx_pair_cmp);
    sv_setsv(retval, avref);

    FREETMPS;
    LEAVE;
}

TXBM(hash, merge) {
    sv_setsv(retval, tx_merge_hash(aTHX_ st, *MARK, *(MARK + 1)));
}

static const tx_builtin_method_t tx_builtin_method[] = {
    TXBM_SETUP(array,  first,   0, 0),
    TXBM_SETUP(array,  last,    0, 0),
    TXBM_SETUP(array,  size,    0, 0),
    TXBM_SETUP(array,  join,    1, 1),
    TXBM_SETUP(array,  reverse, 0, 0),
    TXBM_SETUP(array,  sort,    0, 1), /* can take a compare function */
    TXBM_SETUP(array,  map,     1, 1),
    TXBM_SETUP(array,  reduce,  1, 1),
    TXBM_SETUP(array,  merge,   1, 1),

    TXBM_SETUP(hash,   size,    0, 0),
    TXBM_SETUP(hash,   keys,    0, 0), /* TODO: can take a compare function */
    TXBM_SETUP(hash,   values,  0, 0), /* TODO: can take a compare function */
    TXBM_SETUP(hash,   kv,      0, 0), /* TODO: can take a compare function */
    TXBM_SETUP(hash,   merge,   1, 1),
};

static const size_t tx_num_builtin_method
    = sizeof(tx_builtin_method) / sizeof(tx_builtin_method[0]);

SV*
tx_methodcall(pTHX_ tx_state_t* const st, SV* const method) {
    /* PUSHMARK must be done */
    dSP;
    dMARK;
    dORIGMARK;
    SV* const invocant = *(++MARK);
    const char* type_name;
    SV* fq_name;
    HE* he;
    SV* retval;

    if(sv_isobject(invocant)) {
        PUSHMARK(ORIGMARK); /* re-pushmark */
        return tx_call_sv(aTHX_ st, method, G_METHOD, "method call");
    }

    retval = NULL;
    if(SvROK(invocant)) {
        SV* const referent = SvRV(invocant);
        if(SvTYPE(referent) == SVt_PVAV) {
            type_name = "array::";
        }
        else if(SvTYPE(referent) == SVt_PVHV) {
            type_name = "hash::";
        }
        else {
            type_name = "scalar::";
        }
    }
    else {
        if(SvOK(invocant)) {
            type_name = "scalar::";
        }
        else {
            type_name = "nil::";
        }
    }

    /* make type::method */
    fq_name = st->targ;
    sv_setpv(fq_name, type_name);
    sv_catsv(fq_name, method);

    he = hv_fetch_ent(st->symbol, fq_name, FALSE, 0U);
    if(he) {
        SV* const entity = HeVAL(he);

        if(SvIOK(entity)) {
            I32 const items = SP - MARK;
            const tx_builtin_method_t* bm;

            if(SvUVX(entity) >= tx_num_builtin_method) {
                croak("Oops: Builtin method index of %"SVf" is out of range",
                    fq_name);
            }

            bm = &tx_builtin_method[SvUVX(entity)];

            if(!(items >= bm->nargs_min && items <= bm->nargs_max)) {
                tx_error(aTHX_ st, "Wrong number of arguments for %"SVf,
                    method);
                goto finish;
            }

            retval = st->targ;
            bm->body(aTHX_ st, retval, method, MARK);
            goto finish;
        }
        else { /* user defined methods */
            PUSHMARK(ORIGMARK); /* re-pushmark */
            return tx_proccall(aTHX_ st, entity, "method call");
        }
    }
    if(!SvOK(invocant)) {
        tx_warn(aTHX_ st, "Use of nil to invoke method %"SVf, method);
        goto finish;
    }
    tx_error(aTHX_ st, "Undefined method %"SVf" called for %s", method,
        tx_neat(aTHX_ invocant));

    finish:
    SP = ORIGMARK;
    PUTBACK;
    return retval ? retval : &PL_sv_undef;
}

void
tx_register_builtin_methods(pTHX_ HV* const hv) {
    U32 i;
    assert(hv);
    for(i = 0; i < tx_num_builtin_method; i++) {
        const tx_builtin_method_t* const bm = &tx_builtin_method[i];
        SV* const sv = *hv_fetch(hv, bm->name, strlen(bm->name), TRUE);

        if(!SvOK(sv)) { /* users can override it */
            TAINT_NOT;
            sv_setiv(sv, i);
        }
    }
}

#line 525 "src/xslate_methods.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
	    Perl_croak_nocontext("Usage: %s::%s(%s)", hvname, gvname, params);
        else
	    Perl_croak_nocontext("Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
	Perl_croak_nocontext("Usage: CODE(0x%" UVxf ")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#define croak_xs_usage        S_croak_xs_usage

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#if PERL_VERSION_LE(5, 21, 5)
#  define newXS_deffile(a,b) Perl_newXS(aTHX_ a,b,file)
#else
#  define newXS_deffile(a,b) Perl_newXS_deffile(aTHX_ a,b)
#endif

#line 669 "src/xslate_methods.c"
#ifdef USE_ITHREADS
#define XSubPPtmpAAAA 1


XS_EUPXS(XS_Text__Xslate__Type__Pair_CLONE); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Text__Xslate__Type__Pair_CLONE)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
    {
#line 531 "src/xslate_methods.xs"
{
    MY_CXT_CLONE;
    MY_CXT.pair_stash = gv_stashpvs(TX_PAIR_CLASS, GV_ADDMULTI);
    PERL_UNUSED_VAR(items);
}
#line 687 "src/xslate_methods.c"
    }
    XSRETURN_EMPTY;
}

#endif

XS_EUPXS(XS_Text__Xslate__Type__Pair_key); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Text__Xslate__Type__Pair_key)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "pair");
    {
	AV*	pair;

	STMT_START {
		SV* const xsub_tmp_sv = ST(0);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVAV){
		    pair = (AV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak_nocontext("%s: %s is not an ARRAY reference",
				GvNAME(CvGV(cv)),
				"pair");
		}
	} STMT_END
;
#line 545 "src/xslate_methods.xs"
{
    ST(0) = *av_fetch(pair, ix, TRUE);
}
#line 721 "src/xslate_methods.c"
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_Text__Xslate__Methods); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_Text__Xslate__Methods)
{
#if PERL_VERSION_LE(5, 21, 5)
    dVAR; dXSARGS;
#else
    dVAR; dXSBOOTARGSAPIVERCHK;
#endif
#if PERL_VERSION_LE(5, 8, 999) /* PERL_VERSION_LT is 5.33+ */
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(file);

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#if PERL_VERSION_LE(5, 21, 5) && defined(XS_APIVERSION_BOOTCHECK)
  XS_APIVERSION_BOOTCHECK;
#endif

    {
        CV * cv;

#if XSubPPtmpAAAA
        newXS_deffile("Text::Xslate::Type::Pair::CLONE", XS_Text__Xslate__Type__Pair_CLONE);
#endif
        cv = newXS_deffile("Text::Xslate::Type::Pair::key", XS_Text__Xslate__Type__Pair_key);
        XSANY.any_i32 = 0;
        cv = newXS_deffile("Text::Xslate::Type::Pair::value", XS_Text__Xslate__Type__Pair_key);
        XSANY.any_i32 = 1;
    }

    /* Initialisation Section */

#line 521 "src/xslate_methods.xs"
{
    MY_CXT_INIT;
    MY_CXT.pair_stash = gv_stashpvs(TX_PAIR_CLASS, GV_ADDMULTI);
}

#if XSubPPtmpAAAA
#endif
#line 773 "src/xslate_methods.c"

    /* End of Initialisation Section */

#if PERL_VERSION_LE(5, 21, 5)
#  if PERL_VERSION_GE(5, 9, 0)
    if (PL_unitcheckav)
        call_list(PL_scopestack_ix, PL_unitcheckav);
#  endif
    XSRETURN_YES;
#else
    Perl_xs_boot_epilog(aTHX_ ax);
#endif
}

