/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.43 from the
 * contents of XS.xs. Do not edit this file, edit XS.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "lib/WWW/Form/UrlEncoded/XS.xs"
#ifdef __cplusplus
extern "C" {
#endif

#define PERL_NO_GET_CONTEXT /* we want efficiency */
#include <EXTERN.h>
#include <perl.h>
#include <XSUB.h>

#ifdef __cplusplus
} /* extern "C" */
#endif

#include "ppport.h"

static char escapes[256] =
/*  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f */
{
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,
    1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0,
    1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
};
static char xdigit[16] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};

static SV *
url_decode(pTHX_ const char *src, int start, int end) {
    int dlen = 0, i = 0;
    char *d;
    char s2, s3;
    SV * dst;
    dst = newSV(0);
    (void)SvUPGRADE(dst, SVt_PV);
    d = SvGROW(dst, (end - start) * 3 + 1);

    for (i = start; i < end; i++ ) {
        if (src[i] == '+'){
            d[dlen++] = ' ';
        }
        else if ( src[i] == '%' && isxdigit(src[i+1]) && isxdigit(src[i+2]) ) {
            s2 = src[i+1];
            s3 = src[i+2];
            s2 -= s2 <= '9' ? '0'
                : s2 <= 'F' ? 'A' - 10
                            : 'a' - 10;
            s3 -= s3 <= '9' ? '0'
                : s3 <= 'F' ? 'A' - 10
                            : 'a' - 10;
            d[dlen++] = s2 * 16 + s3;
            i += 2;
        }
        else {
            d[dlen++] = src[i];
        }
    }
    SvCUR_set(dst, dlen);
    *SvEND(dst) = '\0';
    SvPOK_only(dst);
    return dst;
}

static
void
url_encode_key(const char *src, int src_len, char *d, int *key_len) {
    int i, dlen = 0;
    U8 s;
    for (i=0; i < src_len; i++ ) {
        s = src[i];
        if ( s == ' ' ) {
            d[dlen++] = '+';
        }
        else if ( escapes[s] ) {
            d[dlen++] = '%';
            d[dlen++] = xdigit[s >> 4];
            d[dlen++] = xdigit[s % 16];
        }
        else {
            d[dlen++] = s;
        }
    }
    d[dlen++] = '=';
    *key_len = dlen;
}

static
void
url_encode_val(char * dst, int *dst_len, const char * src, int src_len, char * delim, int delim_len ) {
    int i;
    int dlen = *dst_len;
    U8 s;

    for ( i=0; i<src_len; i++) {
        s = src[i];
        if ( s == ' ' ) {
            dst[dlen++] = '+';
        }
        else if ( escapes[s] ) {
            dst[dlen++] = '%';
            dst[dlen++] = xdigit[s >> 4];
            dst[dlen++] = xdigit[s % 16];
        }
        else {
            dst[dlen++] = s;
        }
    }
    for ( i=0; i<delim_len; i++ ) {
        dst[dlen++] = delim[i];
    }
    *dst_len = dlen;
}

static
void
memcat( char * dst, int *dst_len, const char * src, int src_len ) {
    int i;
    int dlen = *dst_len;
    for ( i=0; i<src_len; i++) {
        dst[dlen++] = src[i];
    }
    *dst_len = dlen;
}

static
void
memcopyset( char * dst, int dst_len, const char * src, int src_len ) {
    int i;
    int dlen = dst_len;
    for ( i=0; i<src_len; i++) {
        dst[dlen++] = src[i];
    }
}

static
char *
svpv2char(pTHX_ SV *string, STRLEN *len, int utf8) {
    char *str;
    STRLEN str_len;
    if ( utf8 == 1 ) {
        SvGETMAGIC(string);
        if (!SvUTF8(string)) {
            string = sv_mortalcopy(string);
            sv_utf8_encode(string);
        }
    }
    str = (char *)SvPV(string,str_len);
    *len = str_len;
    return str;
}

static
void
renewmem(pTHX_ char **d, int *cur, const int req) {
    if ( req > *cur ) {
        *cur = (int) (((req / 256) + 1) * 256);
        Renew(*d, *cur, char);
    }
}

#line 181 "temp/XS.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
	    Perl_croak_nocontext("Usage: %s::%s(%s)", hvname, gvname, params);
        else
	    Perl_croak_nocontext("Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
	Perl_croak_nocontext("Usage: CODE(0x%" UVxf ")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#define croak_xs_usage        S_croak_xs_usage

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#if PERL_VERSION_LE(5, 21, 5)
#  define newXS_deffile(a,b) Perl_newXS(aTHX_ a,b,file)
#else
#  define newXS_deffile(a,b) Perl_newXS_deffile(aTHX_ a,b)
#endif

#line 325 "temp/XS.c"

XS_EUPXS(XS_WWW__Form__UrlEncoded__XS_parse_urlencoded); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_WWW__Form__UrlEncoded__XS_parse_urlencoded)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "qs");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	qs = ST(0)
;
#line 179 "lib/WWW/Form/UrlEncoded/XS.xs"
    char *src, *prev, *p;
    int i, prev_s=0, f;
    STRLEN src_len;
#line 342 "temp/XS.c"
#line 183 "lib/WWW/Form/UrlEncoded/XS.xs"
    if ( SvOK(qs) ) {
        src = (char *)SvPV(qs,src_len);
        prev = src;
        for ( i=0; i<src_len; i++ ) {
            if ( src[i] == '&' || src[i] == ';') {
                if ( prev[0] == ' ' ) {
                    prev++;
                    prev_s++;
                }
                p = memchr(prev, '=', i - prev_s);
                if ( p == NULL ) {
                    f = 0;
                    p = &prev[i-prev_s];
                }
                else {
                    f = 1;
                }
                mPUSHs(url_decode(aTHX_ src, prev_s, p - prev + prev_s ));
                mPUSHs(url_decode(aTHX_ src, p - prev + prev_s + f, i ));
                prev = &src[i+1];
                prev_s = i + 1;
            }
        }

        if ( i > prev_s ) {
            if ( prev[0] == ' ' ) {
                prev++;
                prev_s++;
            }
            p = memchr(prev, '=', i - prev_s);
            if ( p == NULL ) {
                f = 0;
                p = &prev[i-prev_s];
            }
            else {
                f = 1;
            }
            mPUSHs(url_decode(aTHX_ src, prev_s, p - prev + prev_s ));
            mPUSHs(url_decode(aTHX_ src, p - prev + prev_s + f, i ));
        }

        if ( src[src_len-1] == '&' || src[src_len-1] == ';' ) {
            mPUSHs(newSVpv("",0));
            mPUSHs(newSVpv("",0));
        }

    }
#line 391 "temp/XS.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_WWW__Form__UrlEncoded__XS_parse_urlencoded_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_WWW__Form__UrlEncoded__XS_parse_urlencoded_arrayref)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "qs");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	qs = ST(0)
;
#line 235 "lib/WWW/Form/UrlEncoded/XS.xs"
    char *src, *prev, *p;
    int i, prev_s=0, f;
    AV *av;
    STRLEN src_len;
#line 414 "temp/XS.c"
#line 240 "lib/WWW/Form/UrlEncoded/XS.xs"
    av = newAV();
    ST(0) = sv_2mortal(newRV_noinc((SV *)av));
    if ( SvOK(qs) ) {
        src = (char *)SvPV(qs,src_len);
        prev = src;
        for ( i=0; i<src_len; i++ ) {
            if ( src[i] == '&' || src[i] == ';') {
                if ( prev[0] == ' ' ) {
                    prev++;
                    prev_s++;
                }
                p = memchr(prev, '=', i - prev_s);
                if ( p == NULL ) {
                    f = 0;
                    p = &prev[i-prev_s];
                }
                else {
                    f = 1;
                }
                av_push(av, url_decode(aTHX_ src, prev_s, p - prev + prev_s ));
                av_push(av, url_decode(aTHX_ src, p - prev + prev_s + f, i ));
                prev = &src[i+1];
                prev_s = i + 1;
            }
        }

        if ( i > prev_s ) {
            if ( prev[0] == ' ' ) {
                prev++;
                prev_s++;
            }
            p = memchr(prev, '=', i - prev_s);
            if ( p == NULL ) {
                f = 0;
                p = &prev[i-prev_s];
            }
            else {
                f = 1;
            }
            av_push(av, url_decode(aTHX_ src, prev_s, p - prev + prev_s ));
            av_push(av, url_decode(aTHX_ src, p - prev + prev_s + f, i ));
        }

        if ( src[src_len-1] == '&' || src[src_len-1] == ';' ) {
            av_push(av, newSVpv("",0));
            av_push(av,newSVpv("",0));
        }
    }
    XSRETURN(1);
#line 465 "temp/XS.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_WWW__Form__UrlEncoded__XS_build_urlencoded); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_WWW__Form__UrlEncoded__XS_build_urlencoded)
{
    dVAR; dXSARGS;
    dXSI32;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
    {
#line 296 "lib/WWW/Form/UrlEncoded/XS.xs"
    int i, j, dlen = 0, dsize = 1024, key_len, val_len;
    SV *st_key, *st_val, *av_val;
    AV *a_list, *a_val;
    HV *h_list;
    HE *h_key;
    char *d, *key_src, *val_src, *key, *delim, *delim_val;
    STRLEN key_src_len, val_src_len, delim_len;
#line 488 "temp/XS.c"
	SV *	RETVAL;
#line 304 "lib/WWW/Form/UrlEncoded/XS.xs"
    Newx(d, dsize, char);
    Newx(delim, 4, char);
    delim[0] = '&';
    delim_len = 1;

    if ( SvOK(ST(0)) && SvROK(ST(0)) && SvTYPE(SvRV(ST(0))) == SVt_PVAV ) {
        /* build_urlencoded([a=>z]) */
       if ( items > 1 && SvOK(ST(1)) ) {
           delim_val = svpv2char(aTHX_ ST(1), &delim_len, ix);
           Renew(delim, delim_len ,char);
           memcopyset(delim, 0, delim_val, delim_len);
       }

       a_list = (AV *)SvRV(ST(0));
       for (i=0; i<=av_len(a_list); i++) {
            st_key = *av_fetch(a_list,i,0);
            if ( !SvOK(st_key) ) {
                Newx(key,1,char);
                key_len = 1;
                key[0] = '=';
            }
            else {
                key_src = svpv2char(aTHX_ st_key, &key_src_len, ix);
                Newx(key,key_src_len * 3 + 1, char);
                url_encode_key(key_src, key_src_len, key, &key_len);
            }
            /* value */
            i++;
            if ( i > av_len(a_list) ) {
                /* key is last  */
                renewmem(aTHX_ &d, &dsize, dlen + key_len + delim_len);
                memcat(d, &dlen, key, key_len);
                memcat(d, &dlen, delim, delim_len);
            }
            else {
                st_val = *av_fetch(a_list,i,0);;
                if ( !SvOK(st_val) ) {
                    /* key but last or value is undef */
                    renewmem(aTHX_ &d, &dsize, dlen + key_len + delim_len);
                    memcat(d, &dlen, key, key_len);
                    memcat(d, &dlen, delim, delim_len);
                }
                else if ( SvROK(st_val) && SvTYPE(SvRV(st_val)) == SVt_PVAV ) {
                    /* array ref */
                    a_val = (AV *)SvRV(st_val);
                    for (j=0; j<=av_len(a_val); j++) {
                        av_val = *av_fetch(a_val,j,0);
                        if ( !SvOK(av_val) ) {
                            renewmem(aTHX_ &d, &dsize, dlen + key_len);
                            memcat(d, &dlen, key, key_len);
                        }
                        else {
                            val_src = svpv2char(aTHX_ av_val, &val_src_len, ix);
                            renewmem(aTHX_ &d, &dsize, dlen + key_len + (val_src_len*3) + delim_len + 1);
                            memcat(d, &dlen, key, key_len);
                            url_encode_val(d, &dlen, val_src, val_src_len, delim, delim_len);
                        }
                    }
                }
                else {
                    /* sv */
                    val_src = svpv2char(aTHX_ st_val, &val_src_len, ix);
                    renewmem(aTHX_ &d, &dsize, dlen + key_len + (val_src_len*3) + delim_len + 1);
                    memcat(d, &dlen, key, key_len);
                    url_encode_val(d, &dlen, val_src, val_src_len, delim, delim_len);
                }
            }
            Safefree(key);
        }
    }
    else if ( SvOK(ST(0)) && SvROK(ST(0)) && SvTYPE(SvRV(ST(0))) == SVt_PVHV ) {
        /* build_urlencoded({a=>z]}) */
       if ( items > 1 && SvOK(ST(1)) ) {
           delim_val = svpv2char(aTHX_ ST(1), &delim_len, ix);
           Renew(delim, delim_len ,char);
           memcopyset(delim, 0, delim_val, delim_len);
       }
       h_list = (HV *)SvRV(ST(0));
       hv_iterinit(h_list);
       while ( (h_key = hv_iternext(h_list)) != NULL ) {
           st_key = hv_iterkeysv(h_key);
            if ( !SvOK(st_key) ) {
                Newx(key,1,char);
                key_len = 1;
                key[0] = '=';
            }
            else {
                key_src = svpv2char(aTHX_ st_key, &key_src_len, ix);
                Newx(key,key_src_len * 3 + 1, char);
                url_encode_key(key_src, key_src_len, key, &key_len);
            }
            /* value */
            st_val = HeVAL(h_key);
            if ( !SvOK(st_val) ) {
                /* key but last or value is undef */
                renewmem(aTHX_ &d, &dsize, dlen + key_len + delim_len);
                memcat(d, &dlen, key, key_len);
                memcat(d, &dlen, delim, delim_len);
            }
            else if ( SvROK(st_val) && SvTYPE(SvRV(st_val)) == SVt_PVAV ) {
                /* array ref */
                a_val = (AV *)SvRV(st_val);
                for (j=0; j<=av_len(a_val); j++) {
                    av_val = *av_fetch(a_val,j,0);
                    if ( !SvOK(av_val) ) {
                        renewmem(aTHX_ &d, &dsize, dlen + key_len);
                        memcat(d, &dlen, key, key_len);
                        memcat(d, &dlen, delim, delim_len);
                    }
                    else {
                        val_src = svpv2char(aTHX_ av_val, &val_src_len, ix);
                        renewmem(aTHX_ &d, &dsize, dlen + key_len + (val_src_len*3) + delim_len + 1);
                        memcat(d, &dlen, key, key_len);
                        url_encode_val(d, &dlen, val_src, val_src_len, delim, delim_len);
                    }
                }
            }
            else {
                /* sv */
                val_src = svpv2char(aTHX_ st_val, &val_src_len, ix);
                renewmem(aTHX_ &d, &dsize, dlen + key_len + (val_src_len*3) + delim_len + 1);
                memcat(d, &dlen, key, key_len);
                url_encode_val(d, &dlen, val_src, val_src_len, delim, delim_len);
            }
            Safefree(key);
        }
    }
    else {
        if ( items > 2 && items % 2 == 1 ) {
           delim_val = svpv2char(aTHX_ ST(items-1), &delim_len, ix);
           Renew(delim, delim_len ,char);
           memcopyset(delim, 0, delim_val, delim_len);
           items--;
        }
        for( i=0; i < items; i++ ) {
            st_key = ST(i);
            if ( !SvOK(st_key) ) {
                Newx(key,1,char);
                key_len = 1;
                key[0] = '=';
            }
            else {
                key_src = svpv2char(aTHX_ st_key, &key_src_len, ix);
                Newx(key,key_src_len * 3 + 1, char);
                url_encode_key(key_src, key_src_len, key, &key_len);
            }
            /* value */
            i++;
            if ( i ==  items ) {
                /* key is last  */
                renewmem(aTHX_ &d, &dsize, dlen + key_len + delim_len);
                memcat(d, &dlen, key, key_len);
                memcat(d, &dlen, delim, delim_len);
            }
            else {
                st_val = ST(i);
                if ( !SvOK(st_val) ) {
                    /* key but last or value is undef */
                    renewmem(aTHX_ &d, &dsize, dlen + key_len + delim_len);
                    memcat(d, &dlen, key, key_len);
                    memcat(d, &dlen, delim, delim_len);
                }
                else if ( SvROK(st_val) && SvTYPE(SvRV(st_val)) == SVt_PVAV ) {
                    /* array ref */
                    a_val = (AV *)SvRV(st_val);
                    for (j=0; j<=av_len(a_val); j++) {
                        av_val = *av_fetch(a_val,j,0);
                        if ( !SvOK(av_val) ) {
                            renewmem(aTHX_ &d, &dsize, dlen + key_len);
                            memcat(d, &dlen, key, key_len);
                        }
                        else {
                            val_src = svpv2char(aTHX_ av_val, &val_src_len, ix);
                            renewmem(aTHX_ &d, &dsize, dlen + key_len + (val_src_len*3) + delim_len + 1);
                            memcat(d, &dlen, key, key_len);
                            url_encode_val(d, &dlen, val_src, val_src_len, delim, delim_len);
                        }
                    }
                }
                else {
                    /* sv */
                    val_src = svpv2char(aTHX_ st_val, &val_src_len, ix);
                    renewmem(aTHX_ &d, &dsize, dlen + key_len + (val_src_len*3) + delim_len + 1);
                    memcat(d, &dlen, key, key_len);
                    url_encode_val(d, &dlen, val_src, val_src_len, delim, delim_len);
                }
            }
            Safefree(key);
        }
    }

    if ( dlen > delim_len ) {
      dlen = dlen - delim_len;
    }

    RETVAL = newSVpvn(d, dlen);
    SvPOK_only(RETVAL);
    Safefree(delim);
    Safefree(d);
#line 690 "temp/XS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_WWW__Form__UrlEncoded__XS); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_WWW__Form__UrlEncoded__XS)
{
#if PERL_VERSION_LE(5, 21, 5)
    dVAR; dXSARGS;
#else
    dVAR; dXSBOOTARGSXSAPIVERCHK;
#endif
#if PERL_VERSION_LE(5, 8, 999) /* PERL_VERSION_LT is 5.33+ */
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(file);

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#if PERL_VERSION_LE(5, 21, 5)
    XS_VERSION_BOOTCHECK;
#  ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#  endif
#endif

    {
        CV * cv;

        newXS_deffile("WWW::Form::UrlEncoded::XS::parse_urlencoded", XS_WWW__Form__UrlEncoded__XS_parse_urlencoded);
        newXS_deffile("WWW::Form::UrlEncoded::XS::parse_urlencoded_arrayref", XS_WWW__Form__UrlEncoded__XS_parse_urlencoded_arrayref);
        cv = newXS_deffile("WWW::Form::UrlEncoded::XS::build_urlencoded", XS_WWW__Form__UrlEncoded__XS_build_urlencoded);
        XSANY.any_i32 = 0;
        cv = newXS_deffile("WWW::Form::UrlEncoded::XS::build_urlencoded_utf8", XS_WWW__Form__UrlEncoded__XS_build_urlencoded);
        XSANY.any_i32 = 1;
    }
#if PERL_VERSION_LE(5, 21, 5)
#  if PERL_VERSION_GE(5, 9, 0)
    if (PL_unitcheckav)
        call_list(PL_scopestack_ix, PL_unitcheckav);
#  endif
    XSRETURN_YES;
#else
    Perl_xs_boot_epilog(aTHX_ ax);
#endif
}

