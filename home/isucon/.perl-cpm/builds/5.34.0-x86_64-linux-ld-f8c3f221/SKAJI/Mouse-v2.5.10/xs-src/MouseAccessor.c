/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.43 from the
 * contents of MouseAccessor.xs. Do not edit this file, edit MouseAccessor.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "xs-src/MouseAccessor.xs"
#include "mouse.h"

#define CHECK_INSTANCE(instance) STMT_START{                           \
        assert(instance);                                              \
        if(UNLIKELY(                                                   \
                !(SvROK(instance)                                      \
                && SvTYPE(SvRV(instance)) == SVt_PVHV) )){             \
            croak("Invalid object instance: '%"SVf"'", instance);      \
        }                                                              \
    } STMT_END


#define MOUSE_mg_attribute(mg) MOUSE_xa_attribute(MOUSE_mg_xa(mg))

static MGVTBL mouse_accessor_vtbl; /* MAGIC identity */

#define dMOUSE_self  SV* const self = mouse_accessor_get_self(aTHX_ ax, items, cv)

/* simple instance slot accessor (or Mouse::Meta::Instance) */

SV*
mouse_instance_create(pTHX_ HV* const stash) {
    SV* instance;
    assert(stash);
    assert(SvTYPE(stash) == SVt_PVHV);
    instance = sv_bless( newRV_noinc((SV*)newHV()), stash );
    return sv_2mortal(instance);
}

SV*
mouse_instance_clone(pTHX_ SV* const instance) {
    SV* proto;
    CHECK_INSTANCE(instance);
    assert(SvOBJECT(SvRV(instance)));

    proto = newRV_noinc((SV*)newHVhv((HV*)SvRV(instance)));
    sv_bless(proto, SvSTASH(SvRV(instance)));
    return sv_2mortal(proto);
}

bool
mouse_instance_has_slot(pTHX_ SV* const instance, SV* const slot) {
    assert(slot);
    CHECK_INSTANCE(instance);
    return hv_exists_ent((HV*)SvRV(instance), slot, 0U);
}

SV*
mouse_instance_get_slot(pTHX_ SV* const instance, SV* const slot) {
    HE* he;
    assert(slot);
    CHECK_INSTANCE(instance);
    he = hv_fetch_ent((HV*)SvRV(instance), slot, FALSE, 0U);
    return he ? HeVAL(he) : NULL;
}

SV*
mouse_instance_set_slot(pTHX_ SV* const instance, SV* const slot, SV* const value) {
    HE* he;
    SV* sv;
    assert(slot);
    assert(value);
    CHECK_INSTANCE(instance);
    he = hv_fetch_ent((HV*)SvRV(instance), slot, TRUE, 0U);
    sv = HeVAL(he);
    sv_setsv(sv, value);
    SvSETMAGIC(sv);
    return sv;
}

SV*
mouse_instance_delete_slot(pTHX_ SV* const instance, SV* const slot) {
    assert(instance);
    assert(slot);
    CHECK_INSTANCE(instance);
    return hv_delete_ent((HV*)SvRV(instance), slot, 0, 0U);
}

void
mouse_instance_weaken_slot(pTHX_ SV* const instance, SV* const slot) {
    HE* he;
    assert(slot);
    CHECK_INSTANCE(instance);
    he = hv_fetch_ent((HV*)SvRV(instance), slot, FALSE, 0U);
    if(he){
        SV* const value = HeVAL(he);
        if (SvROK(value) && !SvWEAKREF(value)) {
            sv_rvweaken(value);
        }
    }
}

/* utilities */

STATIC_INLINE SV*
mouse_accessor_get_self(pTHX_ I32 const ax, I32 const items, CV* const cv) {
    if(UNLIKELY( items < 1 )){
        croak("Too few arguments for %s", GvNAME(CvGV(cv)));
    }
    /* NOTE: If self has GETMAGIC, $self->accessor will invoke GETMAGIC
     *       before calling methods, so SvGETMAGIC(self) is not required here.
     */
    return ST(0);
}


CV*
mouse_accessor_generate(pTHX_ SV* const attr, XSUBADDR_t const accessor_impl){
    AV* const xa = mouse_get_xa(aTHX_ attr);
    CV* xsub;
    MAGIC* mg;

    xsub = newXS(NULL, accessor_impl, __FILE__);
    sv_2mortal((SV*)xsub);

    mg = sv_magicext((SV*)xsub, MOUSE_xa_slot(xa),
        PERL_MAGIC_ext, &mouse_accessor_vtbl, (char*)xa, HEf_SVKEY);

    MOUSE_mg_flags(mg) = (U16)MOUSE_xa_flags(xa);

    /* NOTE:
     * although we use MAGIC for gc, we also store mg to
     * CvXSUBANY for efficiency (gfx)
     */
#ifndef MULTIPLICITY
    CvXSUBANY(xsub).any_ptr = (void*)mg;
#endif

    return xsub;
}


/* pushes return values, does auto-deref if needed */
static void
mouse_push_values(pTHX_ SV* const value, U16 const flags){
    dSP;

    assert( flags & MOUSEf_ATTR_SHOULD_AUTO_DEREF && GIMME_V == G_ARRAY );

    if(!(value && SvOK(value))){
        return;
    }

    if(flags & MOUSEf_TC_IS_ARRAYREF){
        AV* av;
        I32 len;
        I32 i;

        if(!IsArrayRef(value)){
            croak("Mouse-panic: Not an ARRAY reference");
        }

        av  = (AV*)SvRV(value);
        len = av_len(av) + 1;
        EXTEND(SP, len);
        for(i = 0; i < len; i++){
            SV** const svp = av_fetch(av, i, FALSE);
            PUSHs(svp ? *svp : &PL_sv_undef);
        }
    }
    else{
        HV* hv;
        HE* he;

        assert(flags & MOUSEf_TC_IS_HASHREF);

        if(!IsHashRef(value)){
            croak("Mouse-panic: Not a HASH reference");
        }

        hv = (HV*)SvRV(value);
        hv_iterinit(hv);
        while((he = hv_iternext(hv))){
            EXTEND(SP, 2);
            PUSHs(hv_iterkeysv(he));
            PUSHs(hv_iterval(hv, he));
        }
    }

    PUTBACK;
}

STATIC_INLINE void
mouse_push_value(pTHX_ SV* const value, U16 const flags) {
    if(flags & MOUSEf_ATTR_SHOULD_AUTO_DEREF && GIMME_V == G_ARRAY){
        mouse_push_values(aTHX_ value, flags);
    }
    else{
        dSP;
        XPUSHs(value ? value : &PL_sv_undef);
        PUTBACK;
    }
}

STATIC_INLINE void
mouse_attr_get(pTHX_ SV* const self, MAGIC* const mg){
    U16 const flags = MOUSE_mg_flags(mg);
    SV* value;

    value = get_slot(self, MOUSE_mg_slot(mg));

    /* check_lazy */
    if( !value && flags & MOUSEf_ATTR_IS_LAZY ){
        value = mouse_xa_set_default(aTHX_ MOUSE_mg_xa(mg), self);
    }

    mouse_push_value(aTHX_ value, flags);
}

static void
mouse_attr_set(pTHX_ SV* const self, MAGIC* const mg, SV* value){
    U16 const flags = MOUSE_mg_flags(mg);
    SV* const slot  = MOUSE_mg_slot(mg);
    SV* old_value;
    int has_old_value = 0;

    /* Store the original value before we change it so it can be
       passed to the trigger */
    if(flags & MOUSEf_ATTR_HAS_TRIGGER && has_slot(self, slot)){
        has_old_value = 1;
        old_value = sv_mortalcopy( get_slot(self, slot) );
    }

    if(flags & MOUSEf_ATTR_HAS_TC){
        value = mouse_xa_apply_type_constraint(aTHX_ MOUSE_mg_xa(mg), value, flags);
    }

    value = set_slot(self, slot, value);

    if(flags & MOUSEf_ATTR_IS_WEAK_REF){
        weaken_slot(self, slot);
    }

    if(flags & MOUSEf_ATTR_HAS_TRIGGER){
        SV* const trigger = mcall0s(MOUSE_mg_attribute(mg), "trigger");
        dSP;

        /* NOTE: triggers can remove value, so
                 value must be copied here,
                 revealed by Net::Google::DataAPI (DANJOU).
         */
        value = sv_mortalcopy(value);

        PUSHMARK(SP);
        EXTEND(SP, 2);
        PUSHs(self);
        PUSHs(value);
        if( has_old_value ) {
            EXTEND(SP, 1);
            PUSHs(old_value);
        }

        PUTBACK;
        call_sv_safe(trigger, G_VOID | G_DISCARD);
        /* need not SPAGAIN */

        /* wrong assert(SvFLAGS(value) > SVTYPEMASK); can be undef/SVt_NULL */
    }

    mouse_push_value(aTHX_ value, flags);
}

XS(XS_Mouse_accessor)
{
    dVAR; dXSARGS;
    dMOUSE_self;
    MAGIC* const mg = MOUSE_get_magic(aTHX_ cv, &mouse_accessor_vtbl);

    SP -= items; /* PPCODE */
    PUTBACK;

    if(items == 1){ /* reader */
        mouse_attr_get(aTHX_ self, mg);
    }
    else if (items == 2){ /* writer */
        mouse_attr_set(aTHX_ self, mg, ST(1));
    }
    else{
        mouse_throw_error(MOUSE_mg_attribute(mg), NULL,
            "Expected exactly one or two argument for an accessor of %"SVf,
            MOUSE_mg_slot(mg));
    }
}


XS(XS_Mouse_reader)
{
    dVAR; dXSARGS;
    dMOUSE_self;
    MAGIC* const mg = MOUSE_get_magic(aTHX_ cv, &mouse_accessor_vtbl);

    if (items != 1) {
        mouse_throw_error(MOUSE_mg_attribute(mg), NULL,
            "Cannot assign a value to a read-only accessor of %"SVf,
            MOUSE_mg_slot(mg));
    }

    SP -= items; /* PPCODE */
    PUTBACK;

    mouse_attr_get(aTHX_ self, mg);
}

XS(XS_Mouse_writer)
{
    dVAR; dXSARGS;
    dMOUSE_self;
    MAGIC* const mg = MOUSE_get_magic(aTHX_ cv, &mouse_accessor_vtbl);

    if (items != 2) {
        mouse_throw_error(MOUSE_mg_attribute(mg), NULL,
            "Too few arguments for a write-only accessor of %"SVf,
            MOUSE_mg_slot(mg));
    }

    SP -= items; /* PPCODE */
    PUTBACK;

    mouse_attr_set(aTHX_ self, mg, ST(1));
}

/* simple accessors */

/*
static MAGIC*
mouse_accessor_get_mg(pTHX_ CV* const xsub){
    return moose_mg_find(aTHX_ (SV*)xsub, &mouse_simple_accessor_vtbl, MOOSEf_DIE_ON_FAIL);
}
*/

CV*
mouse_simple_accessor_generate(pTHX_
    const char* const fq_name, const char* const key, I32 const keylen,
    XSUBADDR_t const accessor_impl, void* const dptr, I32 const dlen) {
    CV* const xsub = newXS((char*)fq_name, accessor_impl, __FILE__);
    SV* const slot = newSVpvn_share(key, keylen, 0U);
    MAGIC* mg;

    if(!fq_name){
        /* anonymous xsubs need sv_2mortal() */
        sv_2mortal((SV*)xsub);
    }

    mg = sv_magicext((SV*)xsub, slot,
        PERL_MAGIC_ext, &mouse_accessor_vtbl, (char*)dptr, dlen);

    SvREFCNT_dec(slot); /* sv_magicext() increases refcnt in mg_obj */
    if(dlen == HEf_SVKEY){
        SvREFCNT_dec(dptr);
    }

    /* NOTE:
     * although we use MAGIC for gc, we also store mg to CvXSUBANY
     * for efficiency (gfx)
     */
#ifndef MULTIPLICITY
    CvXSUBANY(xsub).any_ptr = (void*)mg;
#endif

    return xsub;
}

XS(XS_Mouse_simple_reader)
{
    dVAR; dXSARGS;
    dMOUSE_self;
    MAGIC* const mg = MOUSE_get_magic(aTHX_ cv, &mouse_accessor_vtbl);
    SV* value;

    if (items != 1) {
        croak("Expected exactly one argument for a reader of %"SVf,
            MOUSE_mg_slot(mg));
    }

    value = get_slot(self, MOUSE_mg_slot(mg));
    if(!value) {
        if(MOUSE_mg_ptr(mg)){
            /* the default value must be a SV */
            assert(MOUSE_mg_len(mg) == HEf_SVKEY);
            value = (SV*)MOUSE_mg_ptr(mg);
        }
        else{
            value = &PL_sv_undef;
        }
    }

    ST(0) = value;
    XSRETURN(1);
}


XS(XS_Mouse_simple_writer)
{
    dVAR; dXSARGS;
    dMOUSE_self;
    SV* const slot = MOUSE_mg_slot(MOUSE_get_magic(aTHX_ cv, &mouse_accessor_vtbl));

    if (items != 2) {
        croak("Expected exactly two argument for a writer of %"SVf,
            slot);
    }

    ST(0) = set_slot(self, slot, ST(1));
    XSRETURN(1);
}

XS(XS_Mouse_simple_clearer)
{
    dVAR; dXSARGS;
    dMOUSE_self;
    SV* const slot = MOUSE_mg_slot(MOUSE_get_magic(aTHX_ cv, &mouse_accessor_vtbl));
    SV* value;

    if (items != 1) {
        croak("Expected exactly one argument for a clearer of %"SVf,
            slot);
    }

    value = delete_slot(self, slot);
    ST(0) = value ? value : &PL_sv_undef;
    XSRETURN(1);
}

XS(XS_Mouse_simple_predicate)
{
    dVAR; dXSARGS;
    dMOUSE_self;
    SV* const slot = MOUSE_mg_slot(MOUSE_get_magic(aTHX_ cv, &mouse_accessor_vtbl));

    if (items != 1) {
        croak("Expected exactly one argument for a predicate of %"SVf, slot);
    }

    ST(0) = boolSV( has_slot(self, slot) );
    XSRETURN(1);
}

/* Class::Data::Inheritable-like class accessor */
XS(XS_Mouse_inheritable_class_accessor) {
    dVAR; dXSARGS;
    dMOUSE_self;
    SV* const slot = MOUSE_mg_slot(MOUSE_get_magic(aTHX_ cv, &mouse_accessor_vtbl));
    SV* value;
    HV* stash;

    if(items == 1){ /* reader */
        value = NULL;
    }
    else if (items == 2){ /* writer */
        value = ST(1);
    }
    else{
        croak("Expected exactly one or two argument for a class data accessor"
            "of %"SVf, slot);
        value = NULL; /* -Wuninitialized */
    }

    stash = mouse_get_namespace(aTHX_ self);

    if(!value) { /* reader */
        value = get_slot(self, slot);
        if(!value) {
            AV* const isa   = mro_get_linear_isa(stash);
            I32 const len   = av_len(isa) + 1;
            I32 i;
            for(i = 1; i < len; i++) {
                SV* const klass = MOUSE_av_at(isa, i);
                SV* const meta  = get_metaclass(klass);
                if(!SvOK(meta)){
                    continue; /* skip non-Mouse classes */
                }
                value = get_slot(meta, slot);
                if(value) {
                    break;
                }
            }
            if(!value) {
                value = &PL_sv_undef;
            }
        }
    }
    else { /* writer */
        set_slot(self, slot, value);
        mro_method_changed_in(stash);
    }

    ST(0) = value;
    XSRETURN(1);
}


#line 502 "xs-src/MouseAccessor.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
	    Perl_croak_nocontext("Usage: %s::%s(%s)", hvname, gvname, params);
        else
	    Perl_croak_nocontext("Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
	Perl_croak_nocontext("Usage: CODE(0x%" UVxf ")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#define croak_xs_usage        S_croak_xs_usage

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#if PERL_VERSION_LE(5, 21, 5)
#  define newXS_deffile(a,b) Perl_newXS(aTHX_ a,b,file)
#else
#  define newXS_deffile(a,b) Perl_newXS_deffile(aTHX_ a,b)
#endif

#line 646 "xs-src/MouseAccessor.c"

XS_EUPXS(XS_Mouse__Meta__Method__Accessor__XS__generate_accessor); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Mouse__Meta__Method__Accessor__XS__generate_accessor)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "klass, attr, metaclass");
    {
	CV *	RETVAL;
	SV*	attr = ST(1)
;
#line 500 "xs-src/MouseAccessor.xs"
{
    RETVAL = mouse_accessor_generate(aTHX_ attr, XS_Mouse_accessor);
}
#line 662 "xs-src/MouseAccessor.c"
	{
	    SV * RETVALSV;
	    RETVALSV = newRV((SV*)RETVAL);
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Mouse__Meta__Method__Accessor__XS__generate_reader); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Mouse__Meta__Method__Accessor__XS__generate_reader)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "klass, attr, metaclass");
    {
	CV *	RETVAL;
	SV*	attr = ST(1)
;
#line 509 "xs-src/MouseAccessor.xs"
{
    RETVAL = mouse_accessor_generate(aTHX_ attr, XS_Mouse_reader);
}
#line 688 "xs-src/MouseAccessor.c"
	{
	    SV * RETVALSV;
	    RETVALSV = newRV((SV*)RETVAL);
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Mouse__Meta__Method__Accessor__XS__generate_writer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Mouse__Meta__Method__Accessor__XS__generate_writer)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "klass, attr, metaclass");
    {
	CV *	RETVAL;
	SV*	attr = ST(1)
;
#line 518 "xs-src/MouseAccessor.xs"
{
    RETVAL = mouse_accessor_generate(aTHX_ attr, XS_Mouse_writer);
}
#line 714 "xs-src/MouseAccessor.c"
	{
	    SV * RETVALSV;
	    RETVALSV = newRV((SV*)RETVAL);
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Mouse__Meta__Method__Accessor__XS__generate_clearer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Mouse__Meta__Method__Accessor__XS__generate_clearer)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "klass, attr, metaclass");
    {
	CV *	RETVAL;
	SV*	attr = ST(1)
;
#line 527 "xs-src/MouseAccessor.xs"
{
    SV* const slot = mcall0(attr, mouse_name);
    STRLEN len;
    const char* const pv = SvPV_const(slot, len);
    RETVAL = mouse_simple_accessor_generate(aTHX_ NULL, pv, len, XS_Mouse_simple_clearer, NULL, 0);
}
#line 743 "xs-src/MouseAccessor.c"
	{
	    SV * RETVALSV;
	    RETVALSV = newRV((SV*)RETVAL);
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Mouse__Meta__Method__Accessor__XS__generate_predicate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Mouse__Meta__Method__Accessor__XS__generate_predicate)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "klass, attr, metaclass");
    {
	CV *	RETVAL;
	SV*	attr = ST(1)
;
#line 539 "xs-src/MouseAccessor.xs"
{
    SV* const slot = mcall0(attr, mouse_name);
    STRLEN len;
    const char* const pv = SvPV_const(slot, len);
    RETVAL = mouse_simple_accessor_generate(aTHX_ NULL, pv, len, XS_Mouse_simple_predicate, NULL, 0);
}
#line 772 "xs-src/MouseAccessor.c"
	{
	    SV * RETVALSV;
	    RETVALSV = newRV((SV*)RETVAL);
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_Mouse__Meta__Method__Accessor__XS); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_Mouse__Meta__Method__Accessor__XS)
{
#if PERL_VERSION_LE(5, 21, 5)
    dVAR; dXSARGS;
#else
    dVAR; dXSBOOTARGSAPIVERCHK;
#endif
#if PERL_VERSION_LE(5, 8, 999) /* PERL_VERSION_LT is 5.33+ */
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(file);

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#if PERL_VERSION_LE(5, 21, 5) && defined(XS_APIVERSION_BOOTCHECK)
  XS_APIVERSION_BOOTCHECK;
#endif

        newXS_deffile("Mouse::Meta::Method::Accessor::XS::_generate_accessor", XS_Mouse__Meta__Method__Accessor__XS__generate_accessor);
        newXS_deffile("Mouse::Meta::Method::Accessor::XS::_generate_reader", XS_Mouse__Meta__Method__Accessor__XS__generate_reader);
        newXS_deffile("Mouse::Meta::Method::Accessor::XS::_generate_writer", XS_Mouse__Meta__Method__Accessor__XS__generate_writer);
        newXS_deffile("Mouse::Meta::Method::Accessor::XS::_generate_clearer", XS_Mouse__Meta__Method__Accessor__XS__generate_clearer);
        newXS_deffile("Mouse::Meta::Method::Accessor::XS::_generate_predicate", XS_Mouse__Meta__Method__Accessor__XS__generate_predicate);
#if PERL_VERSION_LE(5, 21, 5)
#  if PERL_VERSION_GE(5, 9, 0)
    if (PL_unitcheckav)
        call_list(PL_scopestack_ix, PL_unitcheckav);
#  endif
    XSRETURN_YES;
#else
    Perl_xs_boot_epilog(aTHX_ ax);
#endif
}

