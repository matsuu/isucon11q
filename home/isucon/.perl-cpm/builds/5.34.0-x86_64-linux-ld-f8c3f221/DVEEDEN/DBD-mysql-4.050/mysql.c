/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.43 from the
 * contents of mysql.xs. Do not edit this file, edit mysql.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "mysql.xs"
/* Hej, Emacs, this is -*- C -*- mode!

   Copyright (c) 2003      Rudolf Lippan
   Copyright (c) 1997-2003 Jochen Wiedmann

   You may distribute under the terms of either the GNU General Public
   License or the Artistic License, as specified in the Perl README file.

*/


#include "dbdimp.h"
#include "constants.h"

#include <errno.h>
#include <string.h>

#define ASYNC_CHECK_XS(h)\
    if(imp_dbh->async_query_in_flight) {\
        do_error(h, 2000, "Calling a synchronous function on an asynchronous handle", "HY000");\
        XSRETURN_UNDEF;\
    }


DBISTATE_DECLARE;


#line 38 "mysql.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
	    Perl_croak_nocontext("Usage: %s::%s(%s)", hvname, gvname, params);
        else
	    Perl_croak_nocontext("Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
	Perl_croak_nocontext("Usage: CODE(0x%" UVxf ")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#define croak_xs_usage        S_croak_xs_usage

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#if PERL_VERSION_LE(5, 21, 5)
#  define newXS_deffile(a,b) Perl_newXS(aTHX_ a,b,file)
#else
#  define newXS_deffile(a,b) Perl_newXS_deffile(aTHX_ a,b)
#endif

#line 182 "mysql.c"

/* INCLUDE:  Including 'mysql.xsi' from 'mysql.xs' */

#include "Driver_xst.h"
#if defined(dbd_st_execute_iv)
#undef dbd_st_execute
#define dbd_st_execute dbd_st_execute_iv
#endif
#if defined(dbd_st_rows_iv)
#undef dbd_st_rows
#define dbd_st_rows dbd_st_rows_iv
#endif
#if defined(dbd_db_do4_iv)
#undef dbd_db_do4
#define dbd_db_do4 dbd_db_do4_iv
#endif

XS_EUPXS(XS_DBD__mysql__dr_dbixs_revision); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__dr_dbixs_revision)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 57 "./mysql.xsi"
    ST(0) = sv_2mortal(newSViv(DBIXS_REVISION));
#line 211 "mysql.c"
	PUTBACK;
	return;
    }
}

#ifdef dbd_discon_all
#define XSubPPtmpAAAA 1


XS_EUPXS(XS_DBD__mysql__dr_discon_all_); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__dr_discon_all_)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "drh");
    {
	SV *	drh = ST(0)
;
	bool	RETVAL;
#line 69 "./mysql.xsi"
    D_imp_drh(drh);
    PERL_UNUSED_VAR(ix);
    RETVAL = dbd_discon_all(drh, imp_drh);
#line 236 "mysql.c"
	ST(0) = boolSV(RETVAL);
    }
    XSRETURN(1);
}

#endif /* dbd_discon_all */
#ifdef dbd_dr_data_sources
#define XSubPPtmpAAAB 1


XS_EUPXS(XS_DBD__mysql__dr_data_sources); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__dr_data_sources)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "drh, attr = Nullsv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	drh = ST(0)
;
	SV *	attr;

	if (items < 2)
	    attr = Nullsv;
	else {
	    attr = ST(1)
;
	}
#line 85 "./mysql.xsi"
    {
        D_imp_drh(drh);
        AV *av = dbd_dr_data_sources(drh, imp_drh, attr);
        if (av) {
            int i;
            int n = AvFILL(av)+1;
            EXTEND(sp, n);
            for (i = 0; i < n; ++i) {
                PUSHs(AvARRAY(av)[i]);
            }
        }
    }
#line 279 "mysql.c"
	PUTBACK;
	return;
    }
}

#endif

XS_EUPXS(XS_DBD__mysql__db__login); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__db__login)
{
    dVAR; dXSARGS;
    if (items < 4 || items > 5)
       croak_xs_usage(cv,  "dbh, dbname, username, password, attribs=Nullsv");
    {
	SV *	dbh = ST(0)
;
	SV *	dbname = ST(1)
;
	SV *	username = ST(2)
;
	SV *	password = ST(3)
;
	SV *	attribs;
	bool	RETVAL;

	if (items < 5)
	    attribs = Nullsv;
	else {
	    attribs = ST(4)
;
	}
#line 115 "./mysql.xsi"
    {
    D_imp_dbh(dbh);
#if !defined(dbd_db_login6_sv)
    STRLEN lna;
    char *u = (SvOK(username)) ? SvPV(username,lna) : (char*)"";
    char *p = (SvOK(password)) ? SvPV(password,lna) : (char*)"";
#endif
#ifdef dbd_db_login6_sv
    RETVAL = dbd_db_login6_sv(dbh, imp_dbh, dbname, username, password, attribs);
#elif defined(dbd_db_login6)
    RETVAL = dbd_db_login6(dbh, imp_dbh, SvPV_nolen(dbname), u, p, attribs);
#else
    PERL_UNUSED_ARG(attribs);
    RETVAL = dbd_db_login( dbh, imp_dbh, SvPV_nolen(dbname), u, p);
#endif
    }
#line 328 "mysql.c"
	ST(0) = boolSV(RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__mysql__db_selectall_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__db_selectall_arrayref)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
    {
#line 138 "./mysql.xsi"
    SV *sth;
    SV **maxrows_svp;
    SV **tmp_svp;
    SV *tmp_sv;
    SV *attr = &PL_sv_undef;
    imp_sth_t *imp_sth;
#line 349 "mysql.c"
#line 145 "./mysql.xsi"
    if (items > 2) {
        attr = ST(2);
        if (SvROK(attr) &&
                (DBD_ATTRIB_TRUE(attr,"Slice",5,tmp_svp) || DBD_ATTRIB_TRUE(attr,"Columns",7,tmp_svp))
        ) {
            /* fallback to perl implementation */
            SV *tmp =dbixst_bounce_method("DBD::mysql::db::SUPER::selectall_arrayref", items);
            SPAGAIN;
            ST(0) = tmp;
            XSRETURN(1);
        }
    }
    /* --- prepare --- */
    if (SvROK(ST(1))) {
        MAGIC *mg;
        sth = ST(1);
        /* switch to inner handle if not already */
        if ( (mg = mg_find(SvRV(sth),'P')) )
            sth = mg->mg_obj;
    }
    else {
        sth = dbixst_bounce_method("prepare", 3);
        SPAGAIN; SP -= items; /* because stack might have been realloc'd */
        if (!SvROK(sth))
            XSRETURN_UNDEF;
        /* switch to inner handle */
        sth = mg_find(SvRV(sth),'P')->mg_obj;
    }
    imp_sth = (imp_sth_t*)(DBIh_COM(sth));
    /* --- bind_param --- */
    if (items > 3) {    /* need to bind params before execute */
        if (!dbdxst_bind_params(sth, imp_sth, items-2, ax+2) ) {
            XSRETURN_UNDEF;
        }
    }
    /* --- execute --- */
    DBIc_ROW_COUNT(imp_sth) = 0;
    if ( dbd_st_execute(sth, imp_sth) <= -2 ) { /* -2 == error */
        XSRETURN_UNDEF;
    }
    /* --- fetchall --- */
    maxrows_svp = DBD_ATTRIB_GET_SVP(attr, "MaxRows", 7);
    tmp_sv = dbdxst_fetchall_arrayref(sth, &PL_sv_undef, (maxrows_svp) ? *maxrows_svp : &PL_sv_undef);
    SPAGAIN;
    ST(0) = tmp_sv;
#line 396 "mysql.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__mysql__db_selectrow_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__db_selectrow_arrayref)
{
    dVAR; dXSARGS;
    dXSI32;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 197 "./mysql.xsi"
    int is_selectrow_array = (ix == 1);
    imp_sth_t *imp_sth;
    SV *sth;
    AV *row_av;
#line 417 "mysql.c"
#line 202 "./mysql.xsi"
    if (SvROK(ST(1))) {
        MAGIC *mg;
        sth = ST(1);
        /* switch to inner handle if not already */
        if ( (mg = mg_find(SvRV(sth),'P')) )
            sth = mg->mg_obj;
    }
    else {
        /* --- prepare --- */
        sth = dbixst_bounce_method("prepare", 3);
        SPAGAIN; SP -= items; /* because stack might have been realloc'd */
        if (!SvROK(sth)) {
            if (is_selectrow_array) { XSRETURN_EMPTY; } else { XSRETURN_UNDEF; }
        }
        /* switch to inner handle */
        sth = mg_find(SvRV(sth),'P')->mg_obj;
    }
    imp_sth = (imp_sth_t*)(DBIh_COM(sth));
    /* --- bind_param --- */
    if (items > 3) {    /* need to bind params before execute */
        if (!dbdxst_bind_params(sth, imp_sth, items-2, ax+2) ) {
            if (is_selectrow_array) { XSRETURN_EMPTY; } else { XSRETURN_UNDEF; }
        }
    }
    /* --- execute --- */
    DBIc_ROW_COUNT(imp_sth) = 0;
    if ( dbd_st_execute(sth, imp_sth) <= -2 ) { /* -2 == error */
        if (is_selectrow_array) { XSRETURN_EMPTY; } else { XSRETURN_UNDEF; }
    }
    /* --- fetchrow_arrayref --- */
    row_av = dbd_st_fetch(sth, imp_sth);
    if (!row_av) {
        if (GIMME == G_SCALAR)
            PUSHs(&PL_sv_undef);
    }
    else if (is_selectrow_array) {
        int i;
        int num_fields = AvFILL(row_av)+1;
        if (GIMME == G_SCALAR)
            num_fields = 1; /* return just first field */
        EXTEND(sp, num_fields);
        for(i=0; i < num_fields; ++i) {
            PUSHs(AvARRAY(row_av)[i]);
        }
    }
    else {
        PUSHs( sv_2mortal(newRV((SV *)row_av)) );
    }
    /* --- finish --- */
#ifdef dbd_st_finish3
    dbd_st_finish3(sth, imp_sth, 0);
#else
    dbd_st_finish(sth, imp_sth);
#endif
#line 473 "mysql.c"
	PUTBACK;
	return;
    }
}

#if defined(dbd_db_do6) || defined(dbd_db_do4)
#define XSubPPtmpAAAC 1


XS_EUPXS(XS_DBD__mysql__db_do); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__db_do)
{
    dVAR; dXSARGS;
    if (items < 2)
       croak_xs_usage(cv,  "dbh, statement, params = Nullsv, ...");
    {
	SV *	dbh = ST(0)
;
	SV *	statement = ST(1)
;
	SV *	params;

	if (items < 3)
	    params = Nullsv;
	else {
	    params = ST(2)
;
	}
#line 266 "./mysql.xsi"
    {
    D_imp_dbh(dbh);
    IV retval;
#ifdef dbd_db_do6
    /* items is a number of arguments passed to XSUB, supplied by xsubpp compiler */
    /* ax contains stack base offset used by ST() macro, supplied by xsubpp compiler */
    I32 offset = (items >= 3) ? 3 : items;
    retval = dbd_db_do6(dbh, imp_dbh, statement, params, items-offset, ax+offset);
#else
    if (items > 3)
        croak_xs_usage(cv,  "dbh, statement, params = Nullsv");
    retval = dbd_db_do4(dbh, imp_dbh, SvPV_nolen(statement), params); /* might be dbd_db_do4_iv via macro */
#endif
    /* remember that dbd_db_do* must return <= -2 for error     */
    if (retval == 0)            /* ok with no rows affected     */
        XST_mPV(0, "0E0");      /* (true but zero)              */
    else if (retval < -1)       /* -1 == unknown number of rows */
        XST_mUNDEF(0);          /* <= -2 means error            */
    else
        XST_mIV(0, retval);     /* typically 1, rowcount or -1  */
    }
#line 524 "mysql.c"
    }
    XSRETURN(1);
}

#endif
#ifdef dbd_db_last_insert_id
#define XSubPPtmpAAAD 1


XS_EUPXS(XS_DBD__mysql__db_last_insert_id); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__db_last_insert_id)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 6)
       croak_xs_usage(cv,  "dbh, catalog=&PL_sv_undef, schema=&PL_sv_undef, table=&PL_sv_undef, field=&PL_sv_undef, attr=Nullsv");
    {
	SV *	dbh = ST(0)
;
	SV *	catalog;
	SV *	schema;
	SV *	table;
	SV *	field;
	SV *	attr;

	if (items < 2)
	    catalog = &PL_sv_undef;
	else {
	    catalog = ST(1)
;
	}

	if (items < 3)
	    schema = &PL_sv_undef;
	else {
	    schema = ST(2)
;
	}

	if (items < 4)
	    table = &PL_sv_undef;
	else {
	    table = ST(3)
;
	}

	if (items < 5)
	    field = &PL_sv_undef;
	else {
	    field = ST(4)
;
	}

	if (items < 6)
	    attr = Nullsv;
	else {
	    attr = ST(5)
;
	}
#line 302 "./mysql.xsi"
    {
    D_imp_dbh(dbh);
    SV *ret = dbd_db_last_insert_id(dbh, imp_dbh, catalog, schema, table, field, attr);
    ST(0) = ret;
    }
#line 589 "mysql.c"
    }
    XSRETURN(1);
}

#endif

XS_EUPXS(XS_DBD__mysql__db_commit); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__db_commit)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    {
	SV *	dbh = ST(0)
;
	bool	RETVAL;
#line 315 "./mysql.xsi"
    D_imp_dbh(dbh);
    if (DBIc_has(imp_dbh,DBIcf_AutoCommit) && DBIc_WARN(imp_dbh))
        warn("commit ineffective with AutoCommit enabled");
    RETVAL = dbd_db_commit(dbh, imp_dbh);
#line 611 "mysql.c"
	ST(0) = boolSV(RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__mysql__db_rollback); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__db_rollback)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    {
	SV *	dbh = ST(0)
;
	bool	RETVAL;
#line 327 "./mysql.xsi"
    D_imp_dbh(dbh);
    if (DBIc_has(imp_dbh,DBIcf_AutoCommit) && DBIc_WARN(imp_dbh))
        warn("rollback ineffective with AutoCommit enabled");
    RETVAL = dbd_db_rollback(dbh, imp_dbh);
#line 633 "mysql.c"
	ST(0) = boolSV(RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__mysql__db_disconnect); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__db_disconnect)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    {
	SV *	dbh = ST(0)
;
	bool	RETVAL;
#line 339 "./mysql.xsi"
    D_imp_dbh(dbh);
    if ( !DBIc_ACTIVE(imp_dbh) ) {
        XSRETURN_YES;
    }
    /* Check for disconnect() being called whilst refs to cursors       */
    /* still exists. This possibly needs some more thought.             */
    if (DBIc_ACTIVE_KIDS(imp_dbh) && DBIc_WARN(imp_dbh) && !PL_dirty) {
        STRLEN lna;
        char *plural = (DBIc_ACTIVE_KIDS(imp_dbh)==1) ? (char*)"" : (char*)"s";
        warn("%s->disconnect invalidates %d active statement handle%s %s",
            SvPV(dbh,lna), (int)DBIc_ACTIVE_KIDS(imp_dbh), plural,
            "(either destroy statement handles or call finish on them before disconnecting)");
    }
    RETVAL = dbd_db_disconnect(dbh, imp_dbh);
    DBIc_ACTIVE_off(imp_dbh);   /* ensure it's off, regardless */
#line 666 "mysql.c"
	ST(0) = boolSV(RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__mysql__db_STORE); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__db_STORE)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "dbh, keysv, valuesv");
    {
	SV *	dbh = ST(0)
;
	SV *	keysv = ST(1)
;
	SV *	valuesv = ST(2)
;
#line 364 "./mysql.xsi"
    D_imp_dbh(dbh);
    if (SvGMAGICAL(valuesv))
        mg_get(valuesv);
    ST(0) = &PL_sv_yes;
    if (!dbd_db_STORE_attrib(dbh, imp_dbh, keysv, valuesv))
        if (!DBIc_DBISTATE(imp_dbh)->set_attr(dbh, keysv, valuesv))
            ST(0) = &PL_sv_no;
#line 694 "mysql.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__mysql__db_FETCH); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__db_FETCH)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "dbh, keysv");
    {
	SV *	dbh = ST(0)
;
	SV *	keysv = ST(1)
;
#line 378 "./mysql.xsi"
    D_imp_dbh(dbh);
    SV *valuesv = dbd_db_FETCH_attrib(dbh, imp_dbh, keysv);
    if (!valuesv)
        valuesv = DBIc_DBISTATE(imp_dbh)->get_attr(dbh, keysv);
    ST(0) = valuesv;    /* dbd_db_FETCH_attrib did sv_2mortal   */
#line 717 "mysql.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__mysql__db_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__db_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	dbh = ST(0)
;
#line 389 "./mysql.xsi"
    /* keep in sync with default DESTROY in DBI.xs */
    D_imp_dbh(dbh);
    ST(0) = &PL_sv_yes;
    if (!DBIc_IMPSET(imp_dbh)) {        /* was never fully set up       */
        STRLEN lna;
        if (DBIc_WARN(imp_dbh) && !PL_dirty && DBIc_DBISTATE(imp_dbh)->debug >= 2)
             PerlIO_printf(DBIc_LOGPIO(imp_dbh),
                "         DESTROY for %s ignored - handle not initialised\n",
                    SvPV(dbh,lna));
    }
    else {
        if (DBIc_IADESTROY(imp_dbh)) {            /* wants ineffective destroy */
            DBIc_ACTIVE_off(imp_dbh);
            if (DBIc_DBISTATE(imp_dbh)->debug)
                 PerlIO_printf(DBIc_LOGPIO(imp_dbh), "         DESTROY %s skipped due to InactiveDestroy\n", SvPV_nolen(dbh));
        }
        if (DBIc_ACTIVE(imp_dbh)) {
            if (!DBIc_has(imp_dbh,DBIcf_AutoCommit)) {
                /* Application is using transactions and hasn't explicitly disconnected.
                    Some databases will automatically commit on graceful disconnect.
                    Since we're about to gracefully disconnect as part of the DESTROY
                    we want to be sure we're not about to implicitly commit changes
                    that are incomplete and should be rolled back. (The DESTROY may
                    be due to a RaiseError, for example.) So we rollback here.
                    This will be harmless if the application has issued a commit,
                    XXX Could add an attribute flag to indicate that the driver
                    doesn't have this problem. Patches welcome.
                */
                if (DBIc_WARN(imp_dbh) /* only warn if likely to be useful... */
                &&  DBIc_is(imp_dbh, DBIcf_Executed) /* has not just called commit/rollback */
            /*  && !DBIc_is(imp_dbh, DBIcf_ReadOnly) -- is not read only */
                && (!PL_dirty || DBIc_DBISTATE(imp_dbh)->debug >= 3)
                ) {
                    warn("Issuing rollback() due to DESTROY without explicit disconnect() of %s handle %s",
                        SvPV_nolen(*hv_fetch((HV*)SvRV(dbh), "ImplementorClass", 16, 1)),
                        SvPV_nolen(*hv_fetch((HV*)SvRV(dbh), "Name", 4, 1))
                    );
                }
                dbd_db_rollback(dbh, imp_dbh);                  /* ROLLBACK! */
            }
            dbd_db_disconnect(dbh, imp_dbh);
            DBIc_ACTIVE_off(imp_dbh);   /* ensure it's off, regardless */
        }
        dbd_db_destroy(dbh, imp_dbh);
    }
#line 780 "mysql.c"
	PUTBACK;
	return;
    }
}

#ifdef dbd_take_imp_data
#define XSubPPtmpAAAE 1


XS_EUPXS(XS_DBD__mysql__db_take_imp_data); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__db_take_imp_data)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "h");
    {
	SV *	h = ST(0)
;
#line 442 "./mysql.xsi"
    D_imp_xxh(h);
    /* dbd_take_imp_data() returns &sv_no (or other defined but false value)
     * to indicate "preparations complete, now call SUPER::take_imp_data" for me.
     * Anything else is returned to the caller via sv_2mortal(sv), typically that
     * would be &sv_undef for error or an SV holding the imp_data.
     */
    SV *sv = dbd_take_imp_data(h, imp_xxh, NULL);
    if (SvOK(sv) && !SvTRUE(sv)) {
        SV *tmp = dbixst_bounce_method("DBD::mysql::db::SUPER::take_imp_data", items);
        SPAGAIN;
        ST(0) = tmp;
    } else {
        ST(0) = sv_2mortal(sv);
    }
#line 814 "mysql.c"
    }
    XSRETURN(1);
}

#endif
#ifdef dbd_db_data_sources
#define XSubPPtmpAAAF 1


XS_EUPXS(XS_DBD__mysql__db_data_sources); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__db_data_sources)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "dbh, attr = Nullsv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	dbh = ST(0)
;
	SV *	attr;

	if (items < 2)
	    attr = Nullsv;
	else {
	    attr = ST(1)
;
	}
#line 466 "./mysql.xsi"
    {
        D_imp_dbh(dbh);
        AV *av = dbd_db_data_sources(dbh, imp_dbh, attr);
        if (av) {
            int i;
            int n = AvFILL(av)+1;
            EXTEND(sp, n);
            for (i = 0; i < n; ++i) {
                PUSHs(AvARRAY(av)[i]);
            }
        }
    }
#line 856 "mysql.c"
	PUTBACK;
	return;
    }
}

#endif

XS_EUPXS(XS_DBD__mysql__st__prepare); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__st__prepare)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "sth, statement, attribs=Nullsv");
    {
	SV *	sth = ST(0)
;
	SV *	statement = ST(1)
;
	SV *	attribs;
	bool	RETVAL;

	if (items < 3)
	    attribs = Nullsv;
	else {
	    attribs = ST(2)
;
	}
#line 495 "./mysql.xsi"
    {
    D_imp_sth(sth);
    DBD_ATTRIBS_CHECK("_prepare", sth, attribs);
#ifdef dbd_st_prepare_sv
    RETVAL = dbd_st_prepare_sv(sth, imp_sth, statement, attribs);
#else
    RETVAL = dbd_st_prepare(sth, imp_sth, SvPV_nolen(statement), attribs);
#endif
    }
#line 894 "mysql.c"
	ST(0) = boolSV(RETVAL);
    }
    XSRETURN(1);
}

#ifdef dbd_st_rows
#define XSubPPtmpAAAG 1


XS_EUPXS(XS_DBD__mysql__st_rows); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__st_rows)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    {
	SV *	sth = ST(0)
;
#line 514 "./mysql.xsi"
    D_imp_sth(sth);
    XST_mIV(0, dbd_st_rows(sth, imp_sth));
#line 916 "mysql.c"
    }
    XSRETURN(1);
}

#endif /* dbd_st_rows */
#ifdef dbd_st_bind_col
#define XSubPPtmpAAAH 1


XS_EUPXS(XS_DBD__mysql__st_bind_col); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__st_bind_col)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "sth, col, ref, attribs=Nullsv");
    {
	SV *	sth = ST(0)
;
	SV *	col = ST(1)
;
	SV *	ref = ST(2)
;
	SV *	attribs;
	bool	RETVAL;

	if (items < 4)
	    attribs = Nullsv;
	else {
	    attribs = ST(3)
;
	}
#line 529 "./mysql.xsi"
    {
    IV sql_type = 0;
    D_imp_sth(sth);
    if (SvGMAGICAL(ref))
        mg_get(ref);
    if (attribs) {
        if (SvNIOK(attribs)) {
            sql_type = SvIV(attribs);
            attribs = Nullsv;
        }
        else {
            SV **svp;
            DBD_ATTRIBS_CHECK("bind_col", sth, attribs);
            /* XXX we should perhaps complain if TYPE is not SvNIOK */
            DBD_ATTRIB_GET_IV(attribs, "TYPE",4, svp, sql_type);
        }
    }
    switch(dbd_st_bind_col(sth, imp_sth, col, ref, sql_type, attribs)) {
    case 2:     RETVAL = TRUE;              /* job done completely */
                break;
    case 1:     /* fallback to DBI default */
                RETVAL = DBIc_DBISTATE(imp_sth)->bind_col(sth, col, ref, attribs);
                break;
    default:    RETVAL = FALSE;             /* dbd_st_bind_col has called set_err */
                break;
    }
    }
#line 976 "mysql.c"
	ST(0) = boolSV(RETVAL);
    }
    XSRETURN(1);
}

#endif /* dbd_st_bind_col */

XS_EUPXS(XS_DBD__mysql__st_bind_param); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__st_bind_param)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "sth, param, value, attribs=Nullsv");
    {
	SV *	sth = ST(0)
;
	SV *	param = ST(1)
;
	SV *	value = ST(2)
;
	SV *	attribs;
	bool	RETVAL;

	if (items < 4)
	    attribs = Nullsv;
	else {
	    attribs = ST(3)
;
	}
#line 568 "./mysql.xsi"
    {
    IV sql_type = 0;
    D_imp_sth(sth);
    if (SvGMAGICAL(value))
        mg_get(value);
    if (attribs) {
        if (SvNIOK(attribs)) {
            sql_type = SvIV(attribs);
            attribs = Nullsv;
        }
        else {
            SV **svp;
            DBD_ATTRIBS_CHECK("bind_param", sth, attribs);
            /* XXX we should perhaps complain if TYPE is not SvNIOK */
            DBD_ATTRIB_GET_IV(attribs, "TYPE",4, svp, sql_type);
        }
    }
    RETVAL = dbd_bind_ph(sth, imp_sth, param, value, sql_type, attribs, FALSE, 0);
    }
#line 1026 "mysql.c"
	ST(0) = boolSV(RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__mysql__st_bind_param_inout); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__st_bind_param_inout)
{
    dVAR; dXSARGS;
    if (items < 4 || items > 5)
       croak_xs_usage(cv,  "sth, param, value_ref, maxlen, attribs=Nullsv");
    {
	SV *	sth = ST(0)
;
	SV *	param = ST(1)
;
	SV *	value_ref = ST(2)
;
	IV	maxlen = (IV)SvIV(ST(3))
;
	SV *	attribs;
	bool	RETVAL;

	if (items < 5)
	    attribs = Nullsv;
	else {
	    attribs = ST(4)
;
	}
#line 599 "./mysql.xsi"
    {
    IV sql_type = 0;
    D_imp_sth(sth);
    SV *value;
    if (!SvROK(value_ref) || SvTYPE(SvRV(value_ref)) > SVt_PVMG)
        croak("bind_param_inout needs a reference to a scalar value");
    value = SvRV(value_ref);
    if (SvREADONLY(value))
        croak("Modification of a read-only value attempted");
    if (SvGMAGICAL(value))
        mg_get(value);
    if (attribs) {
        if (SvNIOK(attribs)) {
            sql_type = SvIV(attribs);
            attribs = Nullsv;
        }
        else {
            SV **svp;
            DBD_ATTRIBS_CHECK("bind_param", sth, attribs);
            DBD_ATTRIB_GET_IV(attribs, "TYPE",4, svp, sql_type);
        }
    }
    RETVAL = dbd_bind_ph(sth, imp_sth, param, value, sql_type, attribs, TRUE, maxlen);
    }
#line 1082 "mysql.c"
	ST(0) = boolSV(RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__mysql__st_execute); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__st_execute)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "sth, ...");
    {
	SV *	sth = ST(0)
;
#line 631 "./mysql.xsi"
    D_imp_sth(sth);
    IV retval;
    if (items > 1) {    /* need to bind params */
        if (!dbdxst_bind_params(sth, imp_sth, items, ax) ) {
            XSRETURN_UNDEF;
        }
    }
    /* XXX this code is duplicated in selectrow_arrayref above  */
    DBIc_ROW_COUNT(imp_sth) = 0;
    retval = dbd_st_execute(sth, imp_sth); /* might be dbd_st_execute_iv via macro */
    /* remember that dbd_st_execute must return <= -2 for error */
    if (retval == 0)            /* ok with no rows affected     */
        XST_mPV(0, "0E0");      /* (true but zero)              */
    else if (retval < -1)       /* -1 == unknown number of rows */
        XST_mUNDEF(0);          /* <= -2 means error            */
    else
        XST_mIV(0, retval);     /* typically 1, rowcount or -1  */
#line 1116 "mysql.c"
    }
    XSRETURN(1);
}

#ifdef dbd_st_execute_for_fetch
#define XSubPPtmpAAAI 1


XS_EUPXS(XS_DBD__mysql__st_execute_for_fetch); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__st_execute_for_fetch)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "sth, fetch_tuple_sub, tuple_status = Nullsv");
    {
	SV *	sth = ST(0)
;
	SV *	fetch_tuple_sub = ST(1)
;
	SV *	tuple_status;

	if (items < 3)
	    tuple_status = Nullsv;
	else {
	    tuple_status = ST(2)
;
	}
#line 658 "./mysql.xsi"
    {
    D_imp_sth(sth);
    SV *ret = dbd_st_execute_for_fetch(sth, imp_sth, fetch_tuple_sub, tuple_status);
    ST(0) = ret;
    }
#line 1150 "mysql.c"
    }
    XSRETURN(1);
}

#endif
#ifdef dbd_st_last_insert_id
#define XSubPPtmpAAAJ 1


XS_EUPXS(XS_DBD__mysql__st_last_insert_id); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__st_last_insert_id)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 6)
       croak_xs_usage(cv,  "sth, catalog=&PL_sv_undef, schema=&PL_sv_undef, table=&PL_sv_undef, field=&PL_sv_undef, attr=Nullsv");
    {
	SV *	sth = ST(0)
;
	SV *	catalog;
	SV *	schema;
	SV *	table;
	SV *	field;
	SV *	attr;

	if (items < 2)
	    catalog = &PL_sv_undef;
	else {
	    catalog = ST(1)
;
	}

	if (items < 3)
	    schema = &PL_sv_undef;
	else {
	    schema = ST(2)
;
	}

	if (items < 4)
	    table = &PL_sv_undef;
	else {
	    table = ST(3)
;
	}

	if (items < 5)
	    field = &PL_sv_undef;
	else {
	    field = ST(4)
;
	}

	if (items < 6)
	    attr = Nullsv;
	else {
	    attr = ST(5)
;
	}
#line 678 "./mysql.xsi"
    {
    D_imp_sth(sth);
    SV *ret = dbd_st_last_insert_id(sth, imp_sth, catalog, schema, table, field, attr);
    ST(0) = ret;
    }
#line 1215 "mysql.c"
    }
    XSRETURN(1);
}

#endif

XS_EUPXS(XS_DBD__mysql__st_fetchrow_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__st_fetchrow_arrayref)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    {
	SV *	sth = ST(0)
;
#line 693 "./mysql.xsi"
    D_imp_sth(sth);
    AV *av;
    PERL_UNUSED_VAR(ix);
    av = dbd_st_fetch(sth, imp_sth);
    ST(0) = (av) ? sv_2mortal(newRV((SV *)av)) : &PL_sv_undef;
#line 1238 "mysql.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__mysql__st_fetchrow_array); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__st_fetchrow_array)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	sth = ST(0)
;
#line 706 "./mysql.xsi"
    D_imp_sth(sth);
    AV *av;
    av = dbd_st_fetch(sth, imp_sth);
    if (av) {
        int i;
        int num_fields = AvFILL(av)+1;
        EXTEND(sp, num_fields);
        for(i=0; i < num_fields; ++i) {
            PUSHs(AvARRAY(av)[i]);
        }
        PERL_UNUSED_VAR(ix);
    }
#line 1269 "mysql.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_DBD__mysql__st_fetchall_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__st_fetchall_arrayref)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 3)
       croak_xs_usage(cv,  "sth, slice=&PL_sv_undef, batch_row_count=&PL_sv_undef");
    {
	SV *	sth = ST(0)
;
	SV *	slice;
	SV *	batch_row_count;

	if (items < 2)
	    slice = &PL_sv_undef;
	else {
	    slice = ST(1)
;
	}

	if (items < 3)
	    batch_row_count = &PL_sv_undef;
	else {
	    batch_row_count = ST(2)
;
	}
#line 726 "./mysql.xsi"
    if (SvOK(slice)) {  /* fallback to perl implementation */
        SV *tmp = dbixst_bounce_method("DBD::mysql::st::SUPER::fetchall_arrayref", 3);
        SPAGAIN;
        ST(0) = tmp;
    }
    else {
        SV *tmp = dbdxst_fetchall_arrayref(sth, slice, batch_row_count);
        SPAGAIN;
        ST(0) = tmp;
    }
#line 1312 "mysql.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__mysql__st_finish); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__st_finish)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    {
	SV *	sth = ST(0)
;
	bool	RETVAL;
#line 742 "./mysql.xsi"
    D_imp_sth(sth);
    D_imp_dbh_from_sth;
    if (!DBIc_ACTIVE(imp_sth)) {
        /* No active statement to finish        */
        XSRETURN_YES;
    }
    if (!DBIc_ACTIVE(imp_dbh)) {
        /* Either an explicit disconnect() or global destruction        */
        /* has disconnected us from the database. Finish is meaningless */
        DBIc_ACTIVE_off(imp_sth);
        XSRETURN_YES;
    }
#ifdef dbd_st_finish3
    RETVAL = dbd_st_finish3(sth, imp_sth, 0);
#else
    RETVAL = dbd_st_finish(sth, imp_sth);
#endif
#line 1346 "mysql.c"
	ST(0) = boolSV(RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__mysql__st_blob_read); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__st_blob_read)
{
    dVAR; dXSARGS;
    if (items < 4 || items > 6)
       croak_xs_usage(cv,  "sth, field, offset, len, destrv=Nullsv, destoffset=0");
    {
	SV *	sth = ST(0)
;
	int	field = (int)SvIV(ST(1))
;
	long	offset = (long)SvIV(ST(2))
;
	long	len = (long)SvIV(ST(3))
;
	SV *	destrv;
	long	destoffset;

	if (items < 5)
	    destrv = Nullsv;
	else {
	    destrv = ST(4)
;
	}

	if (items < 6)
	    destoffset = 0;
	else {
	    destoffset = (long)SvIV(ST(5))
;
	}
#line 772 "./mysql.xsi"
    {
    D_imp_sth(sth);
    if (!destrv)
        destrv = sv_2mortal(newRV(sv_2mortal(newSV(0))));
    if (dbd_st_blob_read(sth, imp_sth, field, offset, len, destrv, destoffset))
         ST(0) = SvRV(destrv);
    else ST(0) = &PL_sv_undef;
    }
#line 1393 "mysql.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__mysql__st_STORE); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__st_STORE)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "sth, keysv, valuesv");
    {
	SV *	sth = ST(0)
;
	SV *	keysv = ST(1)
;
	SV *	valuesv = ST(2)
;
#line 788 "./mysql.xsi"
    D_imp_sth(sth);
    if (SvGMAGICAL(valuesv))
        mg_get(valuesv);
    ST(0) = &PL_sv_yes;
    if (!dbd_st_STORE_attrib(sth, imp_sth, keysv, valuesv))
        if (!DBIc_DBISTATE(imp_sth)->set_attr(sth, keysv, valuesv))
            ST(0) = &PL_sv_no;
#line 1420 "mysql.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__mysql__st_FETCH_attrib); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__st_FETCH_attrib)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "sth, keysv");
    {
	SV *	sth = ST(0)
;
	SV *	keysv = ST(1)
;
#line 805 "./mysql.xsi"
    D_imp_sth(sth);
    SV *valuesv;
    PERL_UNUSED_VAR(ix);
    valuesv = dbd_st_FETCH_attrib(sth, imp_sth, keysv);
    if (!valuesv)
        valuesv = DBIc_DBISTATE(imp_sth)->get_attr(sth, keysv);
    ST(0) = valuesv;    /* dbd_st_FETCH_attrib did sv_2mortal   */
#line 1446 "mysql.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__mysql__st_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__st_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	sth = ST(0)
;
#line 818 "./mysql.xsi"
    /* keep in sync with default DESTROY in DBI.xs */
    D_imp_sth(sth);
    ST(0) = &PL_sv_yes;
    if (!DBIc_IMPSET(imp_sth)) {        /* was never fully set up       */
        STRLEN lna;
        if (DBIc_WARN(imp_sth) && !PL_dirty && DBIc_DBISTATE(imp_sth)->debug >= 2)
             PerlIO_printf(DBIc_LOGPIO(imp_sth),
                "         DESTROY for %s ignored - handle not initialised\n",
                    SvPV(sth,lna));
    }
    else {
        if (DBIc_IADESTROY(imp_sth)) {  /* wants ineffective destroy    */
            DBIc_ACTIVE_off(imp_sth);
            if (DBIc_DBISTATE(imp_sth)->debug)
                 PerlIO_printf(DBIc_LOGPIO(imp_sth), "         DESTROY %s skipped due to InactiveDestroy\n", SvPV_nolen(sth));
        }
        if (DBIc_ACTIVE(imp_sth)) {
            D_imp_dbh_from_sth;
            if (!PL_dirty && DBIc_ACTIVE(imp_dbh)) {
#ifdef dbd_st_finish3
                dbd_st_finish3(sth, imp_sth, 1);
#else
                dbd_st_finish(sth, imp_sth);
#endif
            }
            else {
                DBIc_ACTIVE_off(imp_sth);
            }
        }
        dbd_st_destroy(sth, imp_sth);
    }
#line 1495 "mysql.c"
	PUTBACK;
	return;
    }
}


/* INCLUDE: Returning to 'mysql.xs' from 'mysql.xsi' */


XS_EUPXS(XS_DBD__mysql_constant); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql_constant)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "name, arg");
    {
	char*	name = (char *)SvPV_nolen(ST(0))
;
	char*	arg = (char *)SvPV_nolen(ST(1))
;
	double	RETVAL;
	dXSTARG;
#line 39 "mysql.xs"
    RETVAL = mysql_constant(name, arg);
#line 1520 "mysql.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__mysql__dr__ListDBs); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__dr__ListDBs)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 5)
       croak_xs_usage(cv,  "drh, host=NULL, port=NULL, user=NULL, password=NULL");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	drh = ST(0)
;
	char *	host;
	char *	port;
	char *	user;
	char *	password;

	if (items < 2)
	    host = NULL;
	else {
	    host = (char *)SvPV_nolen(ST(1))
;
	}

	if (items < 3)
	    port = NULL;
	else {
	    port = (char *)SvPV_nolen(ST(2))
;
	}

	if (items < 4)
	    user = NULL;
	else {
	    user = (char *)SvPV_nolen(ST(3))
;
	}

	if (items < 5)
	    password = NULL;
	else {
	    password = (char *)SvPV_nolen(ST(4))
;
	}
#line 54 "mysql.xs"
{
    MYSQL mysql;
    mysql.net.fd = -1;
    MYSQL* sock = mysql_dr_connect(drh, &mysql, NULL, host, port, user, password,
				   NULL, NULL);
    if (sock != NULL)
    {
      MYSQL_ROW cur;
      MYSQL_RES* res = mysql_list_dbs(sock, NULL);
      if (!res)
      {
        do_error(drh, mysql_errno(sock), mysql_error(sock), mysql_sqlstate(sock));
      }
      else
      {
	EXTEND(sp, mysql_num_rows(res));
	while ((cur = mysql_fetch_row(res)))
        {
	  PUSHs(sv_2mortal((SV*)newSVpvn(cur[0], strlen(cur[0]))));
	}
	mysql_free_result(res);
      }
      mysql_close(sock);
    }
}
#line 1596 "mysql.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_DBD__mysql__dr__admin_internal); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__dr__admin_internal)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 8)
       croak_xs_usage(cv,  "drh, dbh, command, dbname=NULL, host=NULL, port=NULL, user=NULL, password=NULL");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV*	drh = ST(0)
;
	SV*	dbh = ST(1)
;
	char*	command = (char *)SvPV_nolen(ST(2))
;
	char*	dbname;
	char*	host;
	char*	port;
	char*	user;
	char*	password;

	if (items < 4)
	    dbname = NULL;
	else {
	    dbname = (char *)SvPV_nolen(ST(3))
;
	}

	if (items < 5)
	    host = NULL;
	else {
	    host = (char *)SvPV_nolen(ST(4))
;
	}

	if (items < 6)
	    port = NULL;
	else {
	    port = (char *)SvPV_nolen(ST(5))
;
	}

	if (items < 7)
	    user = NULL;
	else {
	    user = (char *)SvPV_nolen(ST(6))
;
	}

	if (items < 8)
	    password = NULL;
	else {
	    password = (char *)SvPV_nolen(ST(7))
;
	}
#line 92 "mysql.xs"
{
  MYSQL mysql;
  int retval;
  MYSQL* sock;
#if MYSQL_VERSION_ID >= 50709
  const char *shutdown = "SHUTDOWN";
#endif

  /*
   *  Connect to the database, if required.
 */
  if (SvOK(dbh)) {
    D_imp_dbh(dbh);
    sock = imp_dbh->pmysql;
  }
  else
  {
    mysql.net.fd = -1;
    sock = mysql_dr_connect(drh, &mysql, NULL, host, port, user,  password, NULL, NULL);
    if (sock == NULL)
    {
      do_error(drh, mysql_errno(&mysql), mysql_error(&mysql),
               mysql_sqlstate(&mysql));
      XSRETURN_NO;
    }
  }

  if (strEQ(command, "shutdown"))
#if MYSQL_VERSION_ID < 40103
    retval = mysql_shutdown(sock);
#else
#if MYSQL_VERSION_ID < 50709
    retval = mysql_shutdown(sock, SHUTDOWN_DEFAULT);
#else
    retval = mysql_real_query(sock, shutdown, strlen(shutdown));
#endif
#endif
  else if (strEQ(command, "reload"))
    retval = mysql_reload(sock);
  else if (strEQ(command, "createdb"))
  {
#if MYSQL_VERSION_ID < 40000
    retval = mysql_create_db(sock, dbname);
#else
    char* buffer = malloc(strlen(dbname)+50);
    if (buffer == NULL)
    {
      do_error(drh, JW_ERR_MEM, "Out of memory" ,NULL);
      XSRETURN_NO;
    }
    else
    {
      strcpy(buffer, "CREATE DATABASE ");
      strcat(buffer, dbname);
      retval = mysql_real_query(sock, buffer, strlen(buffer));
      free(buffer);
    }
#endif
  }
  else if (strEQ(command, "dropdb"))
  {
#if MYSQL_VERSION_ID < 40000
    retval = mysql_drop_db(sock, dbname);
#else
    char* buffer = malloc(strlen(dbname)+50);
    if (buffer == NULL)
    {
      do_error(drh, JW_ERR_MEM, "Out of memory" ,NULL);
      XSRETURN_NO;
    }
    else
    {
      strcpy(buffer, "DROP DATABASE ");
      strcat(buffer, dbname);
      retval = mysql_real_query(sock, buffer, strlen(buffer));
      free(buffer);
    }
#endif
  }
  else
  {
    croak("Unknown command: %s", command);
  }
  if (retval)
  {
    do_error(SvOK(dbh) ? dbh : drh, mysql_errno(sock),
             mysql_error(sock) ,mysql_sqlstate(sock));
  }

  if (SvOK(dbh))
  {
    mysql_close(sock);
  }
  if (retval)
    XSRETURN_NO;
  else 
    XSRETURN_YES;
}
#line 1757 "mysql.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_DBD__mysql__db_type_info_all); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__db_type_info_all)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV*	dbh = ST(0)
;
#line 199 "mysql.xs"
{
  /* 	static AV* types = NULL; */
  /* 	if (!types) { */
  /* 	    D_imp_dbh(dbh); */
  /* 	    if (!(types = dbd_db_type_info_all(dbh, imp_dbh))) { */
  /* 	        croak("Cannot create types array (out of memory?)"); */
  /* 	    } */
  /* 	} */
  /* 	ST(0) = sv_2mortal(newRV_inc((SV*) types)); */
  D_imp_dbh(dbh);
  ASYNC_CHECK_XS(dbh);
  ST(0) = sv_2mortal(newRV_noinc((SV*) dbd_db_type_info_all(dbh,
                                                            imp_dbh)));
  XSRETURN(1);
}
#line 1791 "mysql.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_DBD__mysql__db__ListDBs); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__db__ListDBs)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV*	dbh = ST(0)
;
#line 220 "mysql.xs"
  MYSQL_RES* res;
  MYSQL_ROW cur;

  D_imp_dbh(dbh);

  ASYNC_CHECK_XS(dbh);

  res = mysql_list_dbs(imp_dbh->pmysql, NULL);
  if (!res  &&
      (!mysql_db_reconnect(dbh)  ||
       !(res = mysql_list_dbs(imp_dbh->pmysql, NULL))))
{
  do_error(dbh, mysql_errno(imp_dbh->pmysql),
           mysql_error(imp_dbh->pmysql), mysql_sqlstate(imp_dbh->pmysql));
}
else
{
  EXTEND(sp, mysql_num_rows(res));
  while ((cur = mysql_fetch_row(res)))
  {
    PUSHs(sv_2mortal((SV*)newSVpvn(cur[0], strlen(cur[0]))));
  }
  mysql_free_result(res);
}
#line 1834 "mysql.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_DBD__mysql__db_do); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__db_do)
{
    dVAR; dXSARGS;
    if (items < 2)
       croak_xs_usage(cv,  "dbh, statement, attr=Nullsv, ...");
    {
	SV *	dbh = ST(0)
;
	SV *	statement = ST(1)
;
	SV *	attr;

	if (items < 3)
	    attr = Nullsv;
	else {
	    attr = ST(2)
;
	}
#line 253 "mysql.xs"
{
  D_imp_dbh(dbh);
  int num_params= 0;
  int retval;
  struct imp_sth_ph_st* params= NULL;
  MYSQL_RES* result= NULL;
  SV* async = NULL;
#if MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION
  int next_result_rc;
#endif
#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION
  STRLEN slen;
  char            *str_ptr, *buffer;
  int             has_binded;
  int             buffer_length= slen;
  int             buffer_type= 0;
  int             use_server_side_prepare= 0;
  int             disable_fallback_for_server_prepare= 0;
  MYSQL_STMT      *stmt= NULL;
  MYSQL_BIND      *bind= NULL;
#endif
    ASYNC_CHECK_XS(dbh);
    if ((!DBIc_has(imp_dbh, DBIcf_ACTIVE)) &&
        (!mysql_db_reconnect(dbh)))
      XSRETURN_UNDEF;
#if MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION
    while (mysql_next_result(imp_dbh->pmysql)==0)
    {
      MYSQL_RES* res = mysql_use_result(imp_dbh->pmysql);
      if (res)
        mysql_free_result(res);
      }
#endif
#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION

  /*
   * Globally enabled using of server side prepared statement
   * for dbh->do() statements. It is possible to force driver
   * to use server side prepared statement mechanism by adding
   * 'mysql_server_prepare' attribute to do() method localy:
   * $dbh->do($stmt, {mysql_server_prepared=>1});
  */

  use_server_side_prepare = imp_dbh->use_server_side_prepare;
  if (attr)
  {
    SV** svp;
    DBD_ATTRIBS_CHECK("do", dbh, attr);
    svp = DBD_ATTRIB_GET_SVP(attr, "mysql_server_prepare", 20);

    use_server_side_prepare = (svp) ?
      SvTRUE(*svp) : imp_dbh->use_server_side_prepare;

    svp = DBD_ATTRIB_GET_SVP(attr, "mysql_server_prepare_disable_fallback", 37);
    disable_fallback_for_server_prepare = (svp) ?
      SvTRUE(*svp) : imp_dbh->disable_fallback_for_server_prepare;

    svp   = DBD_ATTRIB_GET_SVP(attr, "async", 5);
    async = (svp) ? *svp : &PL_sv_no;
  }
  if (DBIc_DBISTATE(imp_dbh)->debug >= 2)
    PerlIO_printf(DBIc_LOGPIO(imp_dbh),
                  "mysql.xs do() use_server_side_prepare %d, async %d\n",
                  use_server_side_prepare, SvTRUE(async));

  (void)hv_store((HV*)SvRV(dbh), "Statement", 9, SvREFCNT_inc(statement), 0);

  if(SvTRUE(async)) {
    if (disable_fallback_for_server_prepare)
    {
      do_error(dbh, ER_UNSUPPORTED_PS,
               "Async option not supported with server side prepare", "HY000");
      XSRETURN_UNDEF;
    }
    use_server_side_prepare = FALSE; /* for now */
    imp_dbh->async_query_in_flight = imp_dbh;
  }

  if (use_server_side_prepare)
  {
    str_ptr= SvPV(statement, slen);

    stmt= mysql_stmt_init(imp_dbh->pmysql);

    if ((mysql_stmt_prepare(stmt, str_ptr, strlen(str_ptr)))  &&
        (!mysql_db_reconnect(dbh) ||
         (mysql_stmt_prepare(stmt, str_ptr, strlen(str_ptr)))))
    {
      /*
        For commands that are not supported by server side prepared
        statement mechanism lets try to pass them through regular API
      */
      if (!disable_fallback_for_server_prepare && mysql_stmt_errno(stmt) == ER_UNSUPPORTED_PS)
      {
        use_server_side_prepare= 0;
      }
      else
      {
        do_error(dbh, mysql_stmt_errno(stmt), mysql_stmt_error(stmt)
                 ,mysql_stmt_sqlstate(stmt));
        retval=-2;
      }
      mysql_stmt_close(stmt);
      stmt= NULL;
    }
    else
    {
      /*
        'items' is the number of arguments passed to XSUB, supplied
        by xsubpp compiler, as listed in manpage for perlxs
      */
      if (items > 3)
      {
        /*
          Handle binding supplied values to placeholders assume user has
          passed the correct number of parameters
        */
        int i;
        num_params= items - 3;
        Newz(0, bind, (unsigned int) num_params, MYSQL_BIND);

        for (i = 0; i < num_params; i++)
        {
          int defined= 0;
          SV *param= ST(i+3);

          if (param)
          {
            if (SvMAGICAL(param))
              mg_get(param);
            if (SvOK(param))
              defined= 1;
          }
          if (defined)
          {
            buffer= SvPV(param, slen);
            buffer_length= slen;
            buffer_type= MYSQL_TYPE_STRING;
          }
          else
          {
            buffer= NULL;
            buffer_length= 0;
            buffer_type= MYSQL_TYPE_NULL;
          }

          bind[i].buffer_type = buffer_type;
          bind[i].buffer_length= buffer_length;
          bind[i].buffer= buffer;
        }
        has_binded= 0;
      }
      retval = mysql_st_internal_execute41(dbh,
                                           num_params,
                                           &result,
                                           stmt,
                                           bind,
                                           &has_binded);

      if (bind)
        Safefree(bind);

      /*
         as of 5.7, the end of package was deprecated, breaking
         insertfetch with prepared statements enabled
         no need for this as do() doesn't have a result set since
         it's for DML statements only
      */
#if MYSQL_VERSION_ID < 50701
      mysql_stmt_close(stmt);
      stmt= NULL;
#endif

      if (retval == -2) /* -2 means error */
      {
        SV *err = DBIc_ERR(imp_dbh);
        if (!disable_fallback_for_server_prepare && SvIV(err) == ER_UNSUPPORTED_PS)
        {
          use_server_side_prepare = 0;
        }
      }
    }
  }

  if (! use_server_side_prepare)
  {
#endif
    if (items > 3)
    {
      /*  Handle binding supplied values to placeholders	   */
      /*  Assume user has passed the correct number of parameters  */
      int i;
      num_params= items-3;
      Newz(0, params, sizeof(*params)*num_params, struct imp_sth_ph_st);
      for (i= 0;  i < num_params;  i++)
      {
        params[i].value= ST(i+3);
        params[i].type= SQL_VARCHAR;
      }
    }
    retval = mysql_st_internal_execute(dbh, statement, attr, num_params,
                                       params, &result, imp_dbh->pmysql, 0);
#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION
  }
#endif
  if (params)
    Safefree(params);

  if (result)
  {
    mysql_free_result(result);
    result= 0;
  }
#if MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION
  if (retval != -2 && !SvTRUE(async)) /* -2 means error */
    {
      /* more results? -1 = no, >0 = error, 0 = yes (keep looping) */
      while ((next_result_rc= mysql_next_result(imp_dbh->pmysql)) == 0)
      {
        result = mysql_use_result(imp_dbh->pmysql);
          if (result)
            mysql_free_result(result);
            result = NULL;
          }
          if (next_result_rc > 0)
          {
            if (DBIc_DBISTATE(imp_dbh)->debug >= 2)
              PerlIO_printf(DBIc_LOGPIO(imp_dbh),
                            "\t<- do() ERROR: %s\n",
                            mysql_error(imp_dbh->pmysql));

              do_error(dbh, mysql_errno(imp_dbh->pmysql),
                       mysql_error(imp_dbh->pmysql),
                       mysql_sqlstate(imp_dbh->pmysql));
              retval= -2;
          }
    }
#endif
  /* remember that dbd_st_execute must return <= -2 for error	*/
  if (retval == 0)		/* ok with no rows affected	*/
    XST_mPV(0, "0E0");	/* (true but zero)		*/
  else if (retval < -1)	/* -1 == unknown number of rows	*/
    XST_mUNDEF(0);		/* <= -2 means error   		*/
  else
    XST_mIV(0, retval);	/* typically 1, rowcount or -1	*/
}
#line 2107 "mysql.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__mysql__db_ping); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__db_ping)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    {
	SV*	dbh = ST(0)
;
	SV *	RETVAL;
#line 506 "mysql.xs"
    {
      int retval;
/* MySQL 5.7 below 5.7.18 is affected by Bug #78778.
 * MySQL 5.7.18 and higher (including 8.0.3) is affected by Bug #89139.
 *
 * Once Bug #89139 is fixed we can adjust the upper bound of this check.
 *
 * https://bugs.mysql.com/bug.php?id=78778
 * https://bugs.mysql.com/bug.php?id=89139 */
#if !defined(MARIADB_BASE_VERSION) && MYSQL_VERSION_ID >= 50718
      unsigned long long insertid;
#endif

      D_imp_dbh(dbh);
      ASYNC_CHECK_XS(dbh);
#if !defined(MARIADB_BASE_VERSION) && MYSQL_VERSION_ID >= 50718
      insertid = mysql_insert_id(imp_dbh->pmysql);
#endif
      retval = (mysql_ping(imp_dbh->pmysql) == 0);
      if (!retval) {
	if (mysql_db_reconnect(dbh)) {
	  retval = (mysql_ping(imp_dbh->pmysql) == 0);
	}
      }
#if !defined(MARIADB_BASE_VERSION) && MYSQL_VERSION_ID >= 50718
      imp_dbh->pmysql->insert_id = insertid;
#endif
      RETVAL = boolSV(retval);
    }
#line 2153 "mysql.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__mysql__db_quote); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__db_quote)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "dbh, str, type=NULL");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV*	dbh = ST(0)
;
	SV*	str = ST(1)
;
	SV*	type;

	if (items < 3)
	    type = NULL;
	else {
	    type = ST(2)
;
	}
#line 547 "mysql.xs"
    {
        SV* quoted;

        D_imp_dbh(dbh);
        ASYNC_CHECK_XS(dbh);

        quoted = dbd_db_quote(dbh, str, type);
	ST(0) = quoted ? sv_2mortal(quoted) : str;
	XSRETURN(1);
    }
#line 2193 "mysql.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_DBD__mysql__db_mysql_fd); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__db_mysql_fd)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV*	dbh = ST(0)
;
#line 561 "mysql.xs"
    {
        D_imp_dbh(dbh);
        if(imp_dbh->pmysql->net.fd != -1) {
            XSRETURN_IV(imp_dbh->pmysql->net.fd);
        } else {
            XSRETURN_UNDEF;
        }
    }
#line 2220 "mysql.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_DBD__mysql__db_mysql_async_result); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__db_mysql_async_result)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV*	dbh = ST(0)
;
#line 573 "mysql.xs"
    {
        int retval;

        retval = mysql_db_async_result(dbh, NULL);

        if(retval > 0) {
            XSRETURN_IV(retval);
        } else if(retval == 0) {
            XSRETURN_PV("0E0");
        } else {
            XSRETURN_UNDEF;
        }
    }
#line 2252 "mysql.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_DBD__mysql__db_mysql_async_ready); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__db_mysql_async_ready)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV*	dbh = ST(0)
;
#line 590 "mysql.xs"
    {
        int retval;

        retval = mysql_db_async_ready(dbh);
        if(retval > 0) {
            XSRETURN_YES;
        } else if(retval == 0) {
            XSRETURN_NO;
        } else {
            XSRETURN_UNDEF;
        }
    }
#line 2283 "mysql.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_DBD__mysql__db__async_check); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__db__async_check)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dbh");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV*	dbh = ST(0)
;
#line 606 "mysql.xs"
    {
        D_imp_dbh(dbh);
        ASYNC_CHECK_XS(dbh);
        XSRETURN_YES;
    }
#line 2307 "mysql.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_DBD__mysql__st_more_results); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__st_more_results)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    {
	SV *	sth = ST(0)
;
	int	RETVAL;
	dXSTARG;
#line 618 "mysql.xs"
{
#if (MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION)
  D_imp_sth(sth);
  if (dbd_st_more_results(sth, imp_sth))
  {
    RETVAL=1;
  }
  else
  {
    RETVAL=0;
  }
#endif
}
#line 2339 "mysql.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__mysql__st_dataseek); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__st_dataseek)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "sth, pos");
    {
	SV*	sth = ST(0)
;
	int	pos = (int)SvIV(ST(1))
;
	int	RETVAL;
	dXSTARG;
#line 640 "mysql.xs"
{
  D_imp_sth(sth);
#if (MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION)
  if (imp_sth->use_server_side_prepare)
  {
    if (imp_sth->use_mysql_use_result || 1)
    {
      if (imp_sth->result && imp_sth->stmt)
      {
        mysql_stmt_data_seek(imp_sth->stmt, pos);
        imp_sth->fetch_done=0;
        RETVAL = 1;
      }
      else
      {
        RETVAL = 0;
        do_error(sth, JW_ERR_NOT_ACTIVE, "Statement not active" ,NULL);
      }
    }
    else
    {
      RETVAL = 0;
      do_error(sth, JW_ERR_NOT_ACTIVE, "No result set" ,NULL);
    }
  }
  else
  {
#endif
  if (imp_sth->result) {
    mysql_data_seek(imp_sth->result, pos);
    RETVAL = 1;
  } else {
    RETVAL = 0;
    do_error(sth, JW_ERR_NOT_ACTIVE, "Statement not active" ,NULL);
  }
#if (MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION) 
  }
#endif
}
#line 2399 "mysql.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__mysql__st_rows); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__st_rows)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    {
	SV*	sth = ST(0)
;
#line 686 "mysql.xs"
    D_imp_sth(sth);
    char buf[64];
    D_imp_dbh_from_sth;
    if(imp_dbh->async_query_in_flight) {
        if(mysql_db_async_result(sth, &imp_sth->result) < 0) {
            XSRETURN_UNDEF;
        }
    }

  /* fix to make rows able to handle errors and handle max value from 
     affected rows.
     if mysql_affected_row returns an error, it's value is 18446744073709551614,
     while a (my_ulonglong)-1 is  18446744073709551615, so we have to add 1 to
     imp_sth->row_num to know if there's an error
  */
  if (imp_sth->row_num+1 ==  (my_ulonglong) -1)
    sprintf(buf, "%d", -1);
  else
    sprintf(buf, "%llu", imp_sth->row_num);

  ST(0) = sv_2mortal(newSVpvn(buf, strlen(buf)));
#line 2437 "mysql.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__mysql__st_mysql_async_result); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__st_mysql_async_result)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    {
	SV*	sth = ST(0)
;
	int	RETVAL;
	dXSTARG;
#line 711 "mysql.xs"
    {
        D_imp_sth(sth);
        int retval;

        retval= mysql_db_async_result(sth, &imp_sth->result);

        if(retval > 0) {
            imp_sth->row_num = retval;
            XSRETURN_IV(retval);
        } else if(retval == 0) {
            imp_sth->row_num = retval;
            XSRETURN_PV("0E0");
        } else {
            XSRETURN_UNDEF;
        }
    }
#line 2471 "mysql.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_DBD__mysql__st_mysql_async_ready); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__st_mysql_async_ready)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV*	sth = ST(0)
;
#line 733 "mysql.xs"
    {
        int retval;

        retval = mysql_db_async_ready(sth);
        if(retval > 0) {
            XSRETURN_YES;
        } else if(retval == 0) {
            XSRETURN_NO;
        } else {
            XSRETURN_UNDEF;
        }
    }
#line 2502 "mysql.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_DBD__mysql__st__async_check); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__st__async_check)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sth");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV*	sth = ST(0)
;
#line 749 "mysql.xs"
    {
        D_imp_sth(sth);
        D_imp_dbh_from_sth;
        ASYNC_CHECK_XS(sth);
        XSRETURN_YES;
    }
#line 2527 "mysql.c"
	PUTBACK;
	return;
    }
}

#define SQL_CATALOG_NAME_SEPARATOR 41
#define SQL_CATALOG_TERM 42
#define SQL_DBMS_VER 18
#define SQL_IDENTIFIER_QUOTE_CHAR 29
#define SQL_MAXIMUM_STATEMENT_LENGTH 105
#define SQL_MAXIMUM_TABLES_IN_SELECT 106
#define SQL_MAX_TABLE_NAME_LEN 35
#define SQL_SERVER_NAME 13
#define SQL_ASYNC_MODE 10021
#define SQL_MAX_ASYNC_CONCURRENT_STATEMENTS 10022
#define SQL_AM_NONE       0
#define SQL_AM_CONNECTION 1
#define SQL_AM_STATEMENT  2

XS_EUPXS(XS_DBD__mysql__GetInfo_dbd_mysql_get_info); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_DBD__mysql__GetInfo_dbd_mysql_get_info)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "dbh, sql_info_type");
    {
	SV*	dbh = ST(0)
;
	SV*	sql_info_type = ST(1)
;
#line 786 "mysql.xs"
    D_imp_dbh(dbh);
    IV type = 0;
    SV* retsv=NULL;

    if (SvMAGICAL(sql_info_type))
        mg_get(sql_info_type);

    if (SvOK(sql_info_type))
    	type = SvIV(sql_info_type);
    else
    	croak("get_info called with an invalied parameter");

    switch(type) {
    	case SQL_CATALOG_NAME_SEPARATOR:
	    /* (dbc->flag & FLAG_NO_CATALOG) ? WTF is in flag ? */
	    retsv = newSVpvn(".",1);
	    break;
	case SQL_CATALOG_TERM:
	    /* (dbc->flag & FLAG_NO_CATALOG) ? WTF is in flag ? */
	    retsv = newSVpvn("database",8);
	    break;
	case SQL_DBMS_VER:
	    retsv = newSVpvn(
	        imp_dbh->pmysql->server_version,
		strlen(imp_dbh->pmysql->server_version)
	    );
	    break;
	case SQL_IDENTIFIER_QUOTE_CHAR:
	    retsv = newSVpvn("`", 1);
	    break;
	case SQL_MAXIMUM_STATEMENT_LENGTH:
        /* net_buffer_length macro is not defined in MySQL 5.7 and some MariaDB
        versions - if it is not available, use newer mysql_get_option */
#if !defined(net_buffer_length)
            ;
	    unsigned long buffer_len;
	    mysql_get_option(NULL, MYSQL_OPT_NET_BUFFER_LENGTH, &buffer_len);
	    retsv = newSViv(buffer_len);
#else
	    retsv = newSViv(net_buffer_length);
#endif
	    break;
	case SQL_MAXIMUM_TABLES_IN_SELECT:
	    /* newSViv((sizeof(int) > 32) ? sizeof(int)-1 : 31 ); in general? */
	    retsv= newSViv((sizeof(int) == 64 ) ? 63 : 31 );
	    break;
	case SQL_MAX_TABLE_NAME_LEN:
	    retsv= newSViv(NAME_LEN);
	    break;
	case SQL_SERVER_NAME:
	    retsv= newSVpvn(imp_dbh->pmysql->host_info,strlen(imp_dbh->pmysql->host_info));
	    break;
        case SQL_ASYNC_MODE:
            retsv = newSViv(SQL_AM_STATEMENT);
            break;
        case SQL_MAX_ASYNC_CONCURRENT_STATEMENTS:
            retsv = newSViv(1);
            break;
    	default:
 		croak("Unknown SQL Info type: %i", mysql_errno(imp_dbh->pmysql));
    }
    ST(0) = sv_2mortal(retsv);
#line 2621 "mysql.c"
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_DBD__mysql); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_DBD__mysql)
{
#if PERL_VERSION_LE(5, 21, 5)
    dVAR; dXSARGS;
#else
    dVAR; dXSBOOTARGSXSAPIVERCHK;
#endif
#if PERL_VERSION_LE(5, 8, 999) /* PERL_VERSION_LT is 5.33+ */
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(file);

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#if PERL_VERSION_LE(5, 21, 5)
    XS_VERSION_BOOTCHECK;
#  ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#  endif
#endif

        newXS_deffile("DBD::mysql::dr::dbixs_revision", XS_DBD__mysql__dr_dbixs_revision);
#if XSubPPtmpAAAA
        cv = newXS_deffile("DBD::mysql::dr::discon_all_", XS_DBD__mysql__dr_discon_all_);
        XSANY.any_i32 = 0;
        cv = newXS_deffile("DBD::mysql::dr::disconnect_all", XS_DBD__mysql__dr_discon_all_);
        XSANY.any_i32 = 1;
#endif
#if XSubPPtmpAAAB
        newXS_deffile("DBD::mysql::dr::data_sources", XS_DBD__mysql__dr_data_sources);
#endif
        newXS_deffile("DBD::mysql::db::_login", XS_DBD__mysql__db__login);
        newXS_deffile("DBD::mysql::db::selectall_arrayref", XS_DBD__mysql__db_selectall_arrayref);
        cv = newXS_deffile("DBD::mysql::db::selectrow_array", XS_DBD__mysql__db_selectrow_arrayref);
        XSANY.any_i32 = 1;
        cv = newXS_deffile("DBD::mysql::db::selectrow_arrayref", XS_DBD__mysql__db_selectrow_arrayref);
        XSANY.any_i32 = 0;
#if XSubPPtmpAAAC
        newXS_deffile("DBD::mysql::db::do", XS_DBD__mysql__db_do);
#endif
#if XSubPPtmpAAAD
        newXS_deffile("DBD::mysql::db::last_insert_id", XS_DBD__mysql__db_last_insert_id);
#endif
        newXS_deffile("DBD::mysql::db::commit", XS_DBD__mysql__db_commit);
        newXS_deffile("DBD::mysql::db::rollback", XS_DBD__mysql__db_rollback);
        newXS_deffile("DBD::mysql::db::disconnect", XS_DBD__mysql__db_disconnect);
        newXS_deffile("DBD::mysql::db::STORE", XS_DBD__mysql__db_STORE);
        newXS_deffile("DBD::mysql::db::FETCH", XS_DBD__mysql__db_FETCH);
        newXS_deffile("DBD::mysql::db::DESTROY", XS_DBD__mysql__db_DESTROY);
#if XSubPPtmpAAAE
        newXS_deffile("DBD::mysql::db::take_imp_data", XS_DBD__mysql__db_take_imp_data);
#endif
#if XSubPPtmpAAAF
        newXS_deffile("DBD::mysql::db::data_sources", XS_DBD__mysql__db_data_sources);
#endif
        newXS_deffile("DBD::mysql::st::_prepare", XS_DBD__mysql__st__prepare);
#if XSubPPtmpAAAG
        newXS_deffile("DBD::mysql::st::rows", XS_DBD__mysql__st_rows);
#endif
#if XSubPPtmpAAAH
        newXS_deffile("DBD::mysql::st::bind_col", XS_DBD__mysql__st_bind_col);
#endif
        newXS_deffile("DBD::mysql::st::bind_param", XS_DBD__mysql__st_bind_param);
        newXS_deffile("DBD::mysql::st::bind_param_inout", XS_DBD__mysql__st_bind_param_inout);
        newXS_deffile("DBD::mysql::st::execute", XS_DBD__mysql__st_execute);
#if XSubPPtmpAAAI
        newXS_deffile("DBD::mysql::st::execute_for_fetch", XS_DBD__mysql__st_execute_for_fetch);
#endif
#if XSubPPtmpAAAJ
        newXS_deffile("DBD::mysql::st::last_insert_id", XS_DBD__mysql__st_last_insert_id);
#endif
        cv = newXS_deffile("DBD::mysql::st::fetch", XS_DBD__mysql__st_fetchrow_arrayref);
        XSANY.any_i32 = 1;
        cv = newXS_deffile("DBD::mysql::st::fetchrow_arrayref", XS_DBD__mysql__st_fetchrow_arrayref);
        XSANY.any_i32 = 0;
        cv = newXS_deffile("DBD::mysql::st::fetchrow", XS_DBD__mysql__st_fetchrow_array);
        XSANY.any_i32 = 1;
        cv = newXS_deffile("DBD::mysql::st::fetchrow_array", XS_DBD__mysql__st_fetchrow_array);
        XSANY.any_i32 = 0;
        newXS_deffile("DBD::mysql::st::fetchall_arrayref", XS_DBD__mysql__st_fetchall_arrayref);
        newXS_deffile("DBD::mysql::st::finish", XS_DBD__mysql__st_finish);
        newXS_deffile("DBD::mysql::st::blob_read", XS_DBD__mysql__st_blob_read);
        newXS_deffile("DBD::mysql::st::STORE", XS_DBD__mysql__st_STORE);
        cv = newXS_deffile("DBD::mysql::st::FETCH", XS_DBD__mysql__st_FETCH_attrib);
        XSANY.any_i32 = 1;
        cv = newXS_deffile("DBD::mysql::st::FETCH_attrib", XS_DBD__mysql__st_FETCH_attrib);
        XSANY.any_i32 = 0;
        newXS_deffile("DBD::mysql::st::DESTROY", XS_DBD__mysql__st_DESTROY);
        newXS_deffile("DBD::mysql::constant", XS_DBD__mysql_constant);
        newXS_deffile("DBD::mysql::dr::_ListDBs", XS_DBD__mysql__dr__ListDBs);
        newXS_deffile("DBD::mysql::dr::_admin_internal", XS_DBD__mysql__dr__admin_internal);
        newXS_deffile("DBD::mysql::db::type_info_all", XS_DBD__mysql__db_type_info_all);
        newXS_deffile("DBD::mysql::db::_ListDBs", XS_DBD__mysql__db__ListDBs);
        (void)newXSproto_portable("DBD::mysql::db::do", XS_DBD__mysql__db_do, file, "$$;$@");
        (void)newXSproto_portable("DBD::mysql::db::ping", XS_DBD__mysql__db_ping, file, "$");
        (void)newXSproto_portable("DBD::mysql::db::quote", XS_DBD__mysql__db_quote, file, "$$;$");
        newXS_deffile("DBD::mysql::db::mysql_fd", XS_DBD__mysql__db_mysql_fd);
        newXS_deffile("DBD::mysql::db::mysql_async_result", XS_DBD__mysql__db_mysql_async_result);
        newXS_deffile("DBD::mysql::db::mysql_async_ready", XS_DBD__mysql__db_mysql_async_ready);
        newXS_deffile("DBD::mysql::db::_async_check", XS_DBD__mysql__db__async_check);
        newXS_deffile("DBD::mysql::st::more_results", XS_DBD__mysql__st_more_results);
        (void)newXSproto_portable("DBD::mysql::st::dataseek", XS_DBD__mysql__st_dataseek, file, "$$");
        newXS_deffile("DBD::mysql::st::rows", XS_DBD__mysql__st_rows);
        newXS_deffile("DBD::mysql::st::mysql_async_result", XS_DBD__mysql__st_mysql_async_result);
        newXS_deffile("DBD::mysql::st::mysql_async_ready", XS_DBD__mysql__st_mysql_async_ready);
        newXS_deffile("DBD::mysql::st::_async_check", XS_DBD__mysql__st__async_check);
        newXS_deffile("DBD::mysql::GetInfo::dbd_mysql_get_info", XS_DBD__mysql__GetInfo_dbd_mysql_get_info);

    /* Initialisation Section */

#line 39 "./mysql.xsi"
    PERL_UNUSED_VAR(items);
    DBISTATE_INIT;
    /* XXX this interface will change: */
    DBI_IMP_SIZE("DBD::mysql::dr::imp_data_size", sizeof(imp_drh_t));
    DBI_IMP_SIZE("DBD::mysql::db::imp_data_size", sizeof(imp_dbh_t));
    DBI_IMP_SIZE("DBD::mysql::st::imp_data_size", sizeof(imp_sth_t));
    dbd_init(DBIS);

#if XSubPPtmpAAAA
#endif
#if XSubPPtmpAAAB
#endif
#if XSubPPtmpAAAC
#endif
#if XSubPPtmpAAAD
#endif
#if XSubPPtmpAAAE
#endif
#if XSubPPtmpAAAF
#endif
#if XSubPPtmpAAAG
#endif
#if XSubPPtmpAAAH
#endif
#if XSubPPtmpAAAI
#endif
#if XSubPPtmpAAAJ
#endif
#line 2772 "mysql.c"

    /* End of Initialisation Section */

#if PERL_VERSION_LE(5, 21, 5)
#  if PERL_VERSION_GE(5, 9, 0)
    if (PL_unitcheckav)
        call_list(PL_scopestack_ix, PL_unitcheckav);
#  endif
    XSRETURN_YES;
#else
    Perl_xs_boot_epilog(aTHX_ ax);
#endif
}

